<template>
  <ion-page class="customize-page">
    <ion-header class="ion-no-border">
      <ion-toolbar>
        <ion-buttons slot="start">
          <ion-back-button class="back-button" @click="handleBackButton($event)"></ion-back-button>
        </ion-buttons>
        <div class="flex justify-between items-center">
          <ion-title class="customize-title">Customize Cake</ion-title>
          <button v-if="selectedFlavor" id="addToCartBtn" class=" text-gray-50" @click="showAddToCartModal">
            <ion-icon :icon="icons.cartOutline" class="text-3xl text-[#58091F]"></ion-icon>
       
          </button>
        </div>

      </ion-toolbar>
    </ion-header>

    <ion-content>
      <!-- Selections Modal -->
      <div class="selections-modal" v-if="showSelectionsModal">
        <div class="modal-content">
          <!-- Progress Bar -->
          <div class="progress-container">
            <div class="progress-steps">
              <div v-for="step in 3" :key="step" :class="['progress-step', { 
                  'completed': currentStep > step,
                  'active': currentStep === step 
                }]">
                <div class="step-number">{{ step }}</div>
                <div class="step-label">
                  {{ step === 1 ? 'Layers' : step === 2 ? 'Size' : 'Flavor' }}
                </div>
              </div>
            </div>
            <div class="progress-bar">
              <div class="progress-fill" :style="{ width: `${((currentStep - 1) / 2) * 100}%` }"></div>
            </div>
          </div>

          <!-- Step Content -->
          <div class="step-content">
            <!-- Step 1: Number of Layers -->
            <div class="selection-step" v-if="currentStep === 1">
              <div class="step-header">
                <h2 class="step-title">Choose Layers</h2>
                <p class="step-description">How many layers would you like?</p>
              </div>

              <div class="layers-container">
                <button v-for="num in [1, 2, 3]" :key="num"
                  :class="['layer-option', { 'selected': selectedLayers === num }]" @click="selectLayers(num)">
                  <div class="layer-preview">
                    <div v-for="i in num" :key="i" class="preview-layer" :style="{
                        'background': i === 1 ? '#F0E68D' : i === 2 ? '#E6D77A' : '#DCC867',
                        'transform': `translateY(${(num - i) * 12}px)`,
                        'z-index': i
                      }"></div>
                  </div>
                  <div class="layer-info">
                    <div class="layer-main-info">
                      <span class="layer-name">{{ num }} Layer<span v-if="num > 1">s</span></span>

                    </div>

                  </div>
                </button>
              </div>
            </div>

            <!-- Step 2: Cake Size -->
            <div class="selection-step mb-24" v-if="currentStep === 2">
              <div class="">
                <h2 class="step-title">Select Size</h2>
                <p class="step-description">Choose your preferred cake size</p>
              </div>

              <div class="size-options grid  grid-cols-2  gap-4">
                <button v-for="size in sizeOptions" :key="size.name"
                  :class="['size-option', { selected: selectedSize && selectedSize.name === size.name }]"
                  @click="selectSize(size)">
                  <div class="">
                    <div class="size-visual">
                      <div class="cake-circle" :style="{
                          width: (Array.isArray(size.diameter) ? size.diameter[0].diameter : size.diameter) * 10 + 'px',
                          height: (Array.isArray(size.diameter) ? size.diameter[0].diameter : size.diameter) * 10 + 'px'
                        }">
                        <span class="size-label">{{ Array.isArray(size.diameter) ? size.diameter[0].diameter : size.diameter }}"</span>
                      </div>
                    </div>
                    <div class="size-details">
                      <span class="size-name">{{ size.name }}</span>
                      <!-- <span class="size-dimensions">{{ size.diameter }}″ × {{ size.height }}″</span> -->
                      <span class="size-price">₱{{ size.price.toFixed(2) }}</span>
                    </div>
                  </div>
                </button>
              </div>
            </div>

            <!-- Step 3: Cake Flavor -->
            <div class="selection-step mb-24" v-if="currentStep === 3">
              <h2>Choose Your Flavor</h2>
              <p class="step-description">Select your favorite cake flavor</p>
              <div class="options-grid flavor-grid">
                <button v-for="flavor in flavorOptions" :key="flavor.name"
                  :class="['option-button', { selected: selectedFlavor && selectedFlavor.name === flavor.name }]"
                  @click="selectFlavor(flavor)">
                  <div class="option-content">
                    <div class="option-icon">
                      <div :class="['flavor-preview', flavor.name.toLowerCase()]"></div>
                    </div>
                    <div class="option-label">{{ flavor.name }}</div>
                    <div class="flavor-description">{{ flavor.description }}</div>
                  </div>
                </button>
              </div>
            </div>
          </div>

          <!-- Navigation Buttons -->
          <div class="p-4 flex gap-3 absolute bottom-0 left-0 right-0 bg-gray-200">
            <button v-if="currentStep > 1" class="nav-button back" @click="previousStep">
              <span class="back-icon">←</span>
              Back
            </button>
            <button v-if="currentStep < 3" class="nav-button next" @click="nextStep" :disabled="!canProceed">
              Next
              <span class="next-icon">→</span>
            </button>
            <button v-if="currentStep === 3" class="nav-button finish" @click="finishSelection" :disabled="!canProceed">
              3D Cake
              <span class="finish-icon">✓</span>
            </button>
          </div>
        </div>
      </div>

      <!-- Reset Confirmation Modal -->
      <div class="modal-overlay" v-if="showResetConfirmModal">
        <div class="confirmation-modal">
          <div class="modal-header">
            <h3>Reset Design</h3>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to reset the cake design? This will remove all layers and reset all settings.</p>
          </div>
          <div class="modal-footer">
            <button class="cancel-btn" @click="showResetConfirmModal = false">Cancel</button>
            <button class="confirm-btn" @click="confirmReset">Reset Design</button>
          </div>
        </div>
      </div>

      <!-- Back Button Confirmation Modal -->
      <div class="modal-overlay" v-if="showBackConfirmModal">
        <div class="confirmation-modal">
          <div class="modal-header">
            <h3>Leave Page?</h3>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to leave? Your cake design will be lost.</p>
          </div>
          <div class="modal-footer">
            <button class="cancel-btn" @click="showBackConfirmModal = false">Stay</button>
            <button class="confirm-btn" @click="confirmBack">Leave</button>
          </div>
        </div>
      </div>

      <!-- Add to Cart Confirmation Modal -->
      <div class="modal-overlay" v-if="showCartConfirmModal">
        <div class="confirmation-modal">
          <div class="modal-header">
            <h3>Add to Cart</h3>
          </div>
          <div class="modal-body">
            <p>Are you sure you want to add this cake design to your cart?</p>
            <div class="cart-info" v-if="selectedSize">
              <div class="price-info">
                <h4>Order Summary</h4>
                <p><strong>Size:</strong> {{ selectedSize.name }}</p>
                <p><strong>Layers:</strong> {{ selectedLayers }}</p>
                <p><strong>Flavor:</strong> {{ selectedFlavor ? selectedFlavor.name : 'None' }}</p>
                <p class="total-price"><strong>Total Price:</strong> ₱{{ totalPrice.toFixed(2) }}</p>
              </div>
              <div class="contact-form">
                <h4>Special Instructions</h4>
                <div class="form-group">
                  <label for="customerMessage">Add any special requests or instructions:</label>
                  <textarea id="customerMessage" v-model="customerInfo.message"
                    placeholder="Any special requests or delivery instructions"></textarea>
                </div>
              </div>
            </div>
          </div>
          <div class="modal-footer">
            <button class="cancel-btn" @click="showCartConfirmModal = false">Cancel</button>
            <button class="confirm-btn" @click="addToCart" :disabled="!isFormValid">Add to Cart</button>
          </div>
        </div>
      </div>

      <!-- Success Modal removed as user is now redirected to cart directly -->

      <div class="cake-customizer">
        <canvas id="cakeCanvas"></canvas>
        <div class="controls-panel">
          <div class="sticky top-0  z-10 bg-[#F0E68D]">
            <p class=" font-bold text-xl text-center p-2 pt-3 text-[#58091F]">
              <ion-icon :icon="icons.cubeOutline" class="mr-2 align-middle text-2xl"></ion-icon>
              3D Cake Controls
              <ion-icon :icon="icons.settingsOutline" class="ml-2 align-middle text-2xl"></ion-icon>
            </p>
            <div class="flex gap-2 p-4 overflow-x-auto" ref="tabsContainer">
              <button v-if="true" 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-design' }"
                data-tab="tab-design"
                @click="scrollToTab('tab-design')">
                <ion-icon :icon="icons.constructOutline" class="align-middle mr-1"></ion-icon>
                Actions
              </button>
              <button v-if="false" 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-layer-editor' }"
                data-tab="tab-layer-editor"
                @click="scrollToTab('tab-layer-editor')">
                <ion-icon :icon="icons.layersOutline" class="align-middle mr-1"></ion-icon>
                Layer Editor
              </button>
              <button 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-topper' }"
                data-tab="tab-topper"
                @click="scrollToTab('tab-topper')">
                <ion-icon :icon="icons.flameOutline" class="align-middle mr-1"></ion-icon>
                Printed Topper
              </button>
              <button 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-icing' }"
                data-tab="tab-icing"
                @click="scrollToTab('tab-icing')">
                <ion-icon :icon="icons.iceCreamOutline" class="align-middle mr-1"></ion-icon>
                Icing
              </button>
              <button 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-toppings' }"
                data-tab="tab-toppings"
                @click="scrollToTab('tab-toppings')">
                <ion-icon :icon="icons.sparklesOutline" class="align-middle mr-1"></ion-icon>
                Toppings
              </button>
              <button 
                class="tab-button" 
                :class="{ 'active': activeTab === 'tab-greeting' }"
                data-tab="tab-greeting"
                @click="scrollToTab('tab-greeting')">
                <ion-icon :icon="icons.chatbubbleOutline" class="align-middle mr-1"></ion-icon>
                Greeting
              </button>
            </div>
          </div>

          <div class="tab-content" v-show="activeTab === 'tab-design'" id="tab-design">
            <div class="control-group">
              <button v-if="true" id="addLayerBtn" class="action-button">Add New Layer</button>
              <button  id="saveCakeBtn" class="action-button">Save Design</button>
              <input type="file" id="loadCakeInput" accept=".json" style="display: none;">
              <button v-if="true" id="loadCakeBtn" class="action-button"
                onclick="document.getElementById('loadCakeInput').click()">Load Design</button>
              <button v-if="false" id="resetCakeBtn" class="action-button" @click="resetCakeDesign">Reset
                Design</button>

              <div class="p-3 flex gap-2 justify-between">


              </div>

            </div>
          </div>
          <div class="tab-content" v-show="activeTab === 'tab-layer-editor'" id="tab-layer-editor">
            <div id="layerEditPrompt" class="prompt px-3">Click a cake layer in the 3D view to edit it.</div>
            <div id="selectedLayerControlsContainer"></div>
          </div>
          <div class="tab-content" v-show="activeTab === 'tab-topper'" id="tab-topper">
            <div v-if="!selectedLayerId" class="prompt">Click a cake layer in the 3D view to edit its topper.</div>
            <div v-else class="p-4 space-y-4">
              <h3 class="text-xl font-bold text-center p-2 my-2">
                Layer {{ currentLayerNumber }} Topper
              </h3>
              
              <!-- Topper Section -->
              <div class="bg-white rounded-lg p-4 shadow-sm space-y-4">
                <div class="flex items-center space-x-2">
                  <input type="checkbox" 
                    class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                    :checked="selectedLayerConfig?.topper?.enabled"
                    @change="updateLayerProperty(selectedLayerId, 'topper.enabled', $event.target.checked)">
                  <label class="text-gray-700 font-medium cursor-pointer">Enable Printed Topper</label>
                </div>
                <p class="text-xs text-gray-500 pl-6">Add a custom topper to your cake design</p>
                
                <div v-if="selectedLayerConfig?.topper?.enabled" class="space-y-4 pl-6">
                  <!-- Topper Type -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">Topper Type:</label>
                    <select 
                      :value="selectedLayerConfig?.topper?.type || 'none'"
                      @change="updateLayerProperty(selectedLayerId, 'topper.type', $event.target.value)"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                      <option value="none">Select Type</option>
                      <option value="text">Text Only</option>
                      <option value="image">Image</option>
                    </select>
                  </div>
                  
                  <!-- Text Controls -->
                  <div v-if="selectedLayerConfig?.topper?.type === 'text'" class="space-y-4">
                    <!-- Text Input -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">Text:</label>
                      <input type="text" 
                        :value="selectedLayerConfig?.topper?.text || ''"
                        @input="updateLayerProperty(selectedLayerId, 'topper.text', $event.target.value)"
                        placeholder="Enter text for topper"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                    </div>
                    
                    <!-- Font Size -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">
                        Font Size ({{ (selectedLayerConfig?.topper?.fontSize || 1).toFixed(1) }}):
                      </label>
                      <input type="range" 
                        min="0.5" 
                        max="4" 
                        step="0.1"
                        :value="selectedLayerConfig?.topper?.fontSize || 1"
                        @input="handleThrottledTopperInput('topper.fontSize', $event)"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <!-- Font Style -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">Font Style:</label>
                      <select 
                        :value="selectedLayerConfig?.topper?.style || 'normal'"
                        @change="updateLayerProperty(selectedLayerId, 'topper.style', $event.target.value)"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                        <option value="normal">Normal</option>
                        <option value="bold">Bold</option>
                        <option value="italic">Italic</option>
                      </select>
                    </div>
                    
                    <!-- Text Color -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">Text Color:</label>
                      <div class="flex items-center gap-3">
                        <input type="color" 
                          :value="selectedLayerConfig?.topper?.color || '#000000'"
                          @input="updateLayerProperty(selectedLayerId, 'topper.color', $event.target.value)"
                          class="w-14 h-10 p-1 border border-gray-300 rounded-md shadow-sm cursor-pointer">
                        <span class="text-sm font-mono">{{ selectedLayerConfig?.topper?.color || '#000000' }}</span>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Image Controls -->
                  <div v-if="selectedLayerConfig?.topper?.type === 'image'" class="space-y-4">
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">Upload Image:</label>
                      <div class="mt-1 flex justify-center px-6 pt-5 pb-6 border-2 border-gray-300 border-dashed rounded-md hover:border-[#58091F] transition-colors duration-200">
                        <div class="space-y-1 text-center">
                          <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48" aria-hidden="true">
                            <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4h-12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                          </svg>
                          <div class="flex text-sm text-gray-600">
                            <label class="relative cursor-pointer bg-white rounded-md font-medium text-[#58091F] hover:text-[#58091F]/80 focus-within:outline-none">
                              <span>Upload a file</span>
                              <input type="file" 
                                accept="image/*" 
                                @change="handleImageUpload($event)"
                                class="sr-only">
                            </label>
                            <p class="pl-1">or drag and drop</p>
                          </div>
                          <p class="text-xs text-gray-500">PNG, JPG, GIF up to 10MB</p>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Position and Size Controls (shown for both text and image) -->
                  <div v-if="selectedLayerConfig?.topper?.type && selectedLayerConfig?.topper?.type !== 'none'" class="space-y-4">
                    <!-- Position -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">Topper Position:</label>
                      <select 
                        :value="selectedLayerConfig?.topper?.position || 'center'"
                        @change="updateLayerProperty(selectedLayerId, 'topper.position', $event.target.value)"
                        class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                        <option value="center">Center</option>
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                        <option value="front">Front</option>
                        <option value="back">Back</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="front-left">Front Left</option>
                        <option value="front-right">Front Right</option>
                        <option value="back-left">Back Left</option>
                        <option value="back-right">Back Right</option>
                      </select>
                    </div>
                    
                    <!-- Size -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">
                        Topper Size ({{ (selectedLayerConfig?.topper?.size || 1).toFixed(2) }}):
                      </label>
                      <input type="range" 
                        min="0.5" 
                        max="2" 
                        step="0.01"
                        :value="selectedLayerConfig?.topper?.size || 1"
                        @input="handleThrottledTopperInput('topper.size', $event)"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                    
                    <!-- Stick Height -->
                    <div class="space-y-2">
                      <label class="block text-sm font-medium text-gray-700">
                        Stick Height ({{ (selectedLayerConfig?.topper?.stickHeight || 0.4).toFixed(1) }}):
                      </label>
                      <input type="range" 
                        min="0.1" 
                        max="1.5" 
                        step="0.1"
                        :value="selectedLayerConfig?.topper?.stickHeight || 0.4"
                        @input="handleThrottledTopperInput('topper.stickHeight', $event)"
                        class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Icing -->
          <div class="tab-content" v-show="activeTab === 'tab-icing'" id="tab-icing">
            <div v-if="!selectedLayerId" class="prompt">Click a cake layer in the 3D view to edit its icing.</div>
            <div v-else class="p-4 space-y-4">
              <h3 class="text-xl font-bold text-center p-2 my-2">
                Layer {{ currentLayerNumber }} Icing
              </h3>
              
              <!-- Edge Icing Section -->
              <div class="bg-white rounded-lg p-4 shadow-sm space-y-4">
                <div class="flex items-center space-x-2">
                  <input type="checkbox" 
                    class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                    :checked="selectedLayerConfig?.edgeIcing?.enabled"
                    @change="updateLayerProperty(selectedLayerId, 'edgeIcing.enabled', $event.target.checked)">
                  <label class="text-gray-700 font-medium cursor-pointer">Enable Edge Icing</label>
                </div>
                <p class="text-xs text-gray-500 pl-6">Add decorative icing around the edge of your cake</p>
                
                <div v-if="selectedLayerConfig?.edgeIcing?.enabled" class="space-y-4 pl-6">
                  <!-- Edge Style -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">Edge Style:</label>
                    <select 
                      :value="selectedLayerConfig?.edgeIcing?.style || 'smooth'"
                      @change="updateLayerProperty(selectedLayerId, 'edgeIcing.style', $event.target.value)"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                      <option value="smooth">Smooth Ring</option>
                      <option value="curl">Curl Pattern</option>
                      <option value="shell">Shell Pattern</option>
                      <option value="rosette">Rosette Pattern</option>
                      <option value="ruffle">Ruffle Pattern</option>
                      <option value="zigzag">Zigzag Pattern</option>
                    </select>
                  </div>
                  
                  <!-- Edge Color -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">Edge Color:</label>
                    <input type="color" 
                      :value="selectedLayerConfig?.edgeIcing?.color || '#FFFFFF'"
                      @input="updateLayerProperty(selectedLayerId, 'edgeIcing.color', $event.target.value)"
                      class="w-full h-10 p-1 border border-gray-300 rounded-md shadow-sm cursor-pointer">
                  </div>
                  
                  <!-- Edge Thickness -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">
                      Edge Detail/Thickness ({{ (selectedLayerConfig?.edgeIcing?.thickness || 0.05).toFixed(2) }}):
                    </label>
                    <input type="range" 
                      min="0.02" 
                      max="0.3" 
                      step="0.01"
                      :value="selectedLayerConfig?.edgeIcing?.thickness || 0.05"
                      @input="updateLayerProperty(selectedLayerId, 'edgeIcing.thickness', parseFloat($event.target.value))"
                      class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                  </div>
                </div>
              </div>
              
              <!-- Bottom Icing Section -->
              <div class="bg-white rounded-lg p-4 shadow-sm space-y-4">
                <div class="flex items-center space-x-2">
                  <input type="checkbox" 
                    class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                    :checked="selectedLayerConfig?.bottomIcing?.enabled"
                    @change="updateLayerProperty(selectedLayerId, 'bottomIcing.enabled', $event.target.checked)">
                  <label class="text-gray-700 font-medium cursor-pointer">Enable Bottom Icing</label>
                </div>
                <p class="text-xs text-gray-500 pl-6">Add decorative icing to the bottom edge of your cake</p>
                
                <div v-if="selectedLayerConfig?.bottomIcing?.enabled" class="space-y-4 pl-6">
                  <!-- Bottom Style -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">Bottom Style:</label>
                    <select 
                      :value="selectedLayerConfig?.bottomIcing?.style || 'smooth'"
                      @change="updateLayerProperty(selectedLayerId, 'bottomIcing.style', $event.target.value)"
                      class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                      <option value="smooth">Smooth Ring</option>
                      <option value="curl">Curl Pattern</option>
                      <option value="shell">Shell Pattern</option>
                      <option value="rosette">Rosette Pattern</option>
                      <option value="ruffle">Ruffle Pattern</option>
                      <option value="zigzag">Zigzag Pattern</option>
                    </select>
                  </div>
                  
                  <!-- Bottom Color -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">Bottom Color:</label>
                    <input type="color" 
                      :value="selectedLayerConfig?.bottomIcing?.color || '#FFFFFF'"
                      @input="updateLayerProperty(selectedLayerId, 'bottomIcing.color', $event.target.value)"
                      class="w-full h-10 p-1 border border-gray-300 rounded-md shadow-sm cursor-pointer">
                  </div>
                  
                  <!-- Bottom Thickness -->
                  <div class="space-y-2">
                    <label class="block text-sm font-medium text-gray-700">
                      Bottom Detail/Thickness ({{ (selectedLayerConfig?.bottomIcing?.thickness || 0.05).toFixed(2) }}):
                    </label>
                    <input type="range" 
                      min="0.02" 
                      max="0.3" 
                      step="0.01"
                      :value="selectedLayerConfig?.bottomIcing?.thickness || 0.05"
                      @input="updateLayerProperty(selectedLayerId, 'bottomIcing.thickness', parseFloat($event.target.value))"
                      class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Toppings -->
          <div class="tab-content" v-show="activeTab === 'tab-toppings'" id="tab-toppings">
            <div v-if="!selectedLayerId" class="prompt">Click a cake layer in the 3D view to edit its toppings.</div>
            <div v-else class="p-4 space-y-4">
              <h3 class="text-xl font-bold text-center p-2 my-2">
                Layer {{ currentLayerNumber }} Toppings
              </h3>
              
              <div class="bg-white rounded-lg p-4 shadow-sm space-y-4">
                <p class="text-sm font-medium text-gray-700 mb-3">Add toppings to your cake layer:</p>
                
                <!-- Sprinkles -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'sprinkles')"
                      @change="updateToppingState('sprinkles', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Sprinkles</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'sprinkles')" 
                    class="pl-6 text-xs text-gray-500">
                    Colorful sprinkles randomly distributed across the top of the cake
                  </div>
                </div>

                <!-- Flowers -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'flowers')"
                      @change="updateToppingState('flowers', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Flowers</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'flowers')" 
                    class="pl-6 space-y-3">
                    <p class="text-xs text-gray-500">Beautiful edible flowers with colorful petals arranged on your cake</p>
                    
                    <!-- Flower Position Options -->
                    <div class="space-y-2">
                      <label class="text-sm font-medium text-gray-700">Flower Position:</label>
                      <div class="space-y-1">
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="inner" 
                            :checked="!selectedLayerConfig?.flowerPosition || selectedLayerConfig?.flowerPosition === 'inner'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'inner')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Inner (close to center)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="mid" 
                            :checked="selectedLayerConfig?.flowerPosition === 'mid'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'mid')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Mid (middle area)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="outer" 
                            :checked="selectedLayerConfig?.flowerPosition === 'outer'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'outer')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Outer (near edge)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="all" 
                            :checked="selectedLayerConfig?.flowerPosition === 'all'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'all')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">All (full coverage)</span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Cherries -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'cherries')"
                      @change="updateToppingState('cherries', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Cherries</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'cherries')" 
                    class="pl-6 text-xs text-gray-500">
                    Red cherries with green stems placed on top of your cake
                  </div>
                </div>

                <!-- Strawberries -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'strawberries')"
                      @change="updateToppingState('strawberries', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Strawberries</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'strawberries')" 
                    class="pl-6 space-y-3">
                    <p class="text-xs text-gray-500">Fresh strawberries piled naturally on your cake</p>
                    
                    <!-- Strawberry Position Options -->
                    <div class="space-y-2">
                      <label class="text-sm font-medium text-gray-700">Strawberry Position:</label>
                      <div class="space-y-1">
                        <label class="flex items-center">
                          <input type="radio" 
                            name="strawberry_position" 
                            value="inner" 
                            :checked="!selectedLayerConfig?.strawberryPosition || selectedLayerConfig?.strawberryPosition === 'inner'"
                            @change="updateLayerProperty(selectedLayerId, 'strawberryPosition', 'inner')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Inner (close to center)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="strawberry_position" 
                            value="mid" 
                            :checked="selectedLayerConfig?.strawberryPosition === 'mid'"
                            @change="updateLayerProperty(selectedLayerId, 'strawberryPosition', 'mid')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Mid (middle area)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="strawberry_position" 
                            value="outer" 
                            :checked="selectedLayerConfig?.strawberryPosition === 'outer'"
                            @change="updateLayerProperty(selectedLayerId, 'strawberryPosition', 'outer')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Outer (near edge)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="strawberry_position" 
                            value="all" 
                            :checked="selectedLayerConfig?.strawberryPosition === 'all'"
                            @change="updateLayerProperty(selectedLayerId, 'strawberryPosition', 'all')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">All (full coverage)</span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>

                <!-- Blueberries -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'blueberries')"
                      @change="updateToppingState('blueberries', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Blueberries</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'blueberries')" 
                    class="pl-6 text-xs text-gray-500">
                    Fresh blueberries scattered across the top of your cake
                  </div>
                </div>

                <!-- Candles -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'candle')"
                      @change="updateToppingState('candle', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Candles</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'candle')" 
                    class="pl-6 text-xs text-gray-500">
                    Beautiful birthday candles with flames evenly distributed around your cake
                  </div>
                </div>

                <!-- Crush Oreo -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'crush_oreo')"
                      @change="updateToppingState('crush_oreo', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Crush Oreo</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'crush_oreo')" 
                    class="pl-6 text-xs text-gray-500">
                    Crushed Oreo cookies and cream pieces sprinkled across your cake
                  </div>
                </div>

                <!-- Christmas Balls -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'christmas_balls')"
                      @change="updateToppingState('christmas_balls', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Christmas Balls</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'christmas_balls')" 
                    class="pl-6 text-xs text-gray-500">
                    Colorful Christmas ornament balls with golden caps for festive decoration
                  </div>
                </div>

                <!-- Flowers -->
                <div class="space-y-2">
                  <div class="flex items-center space-x-2">
                    <input type="checkbox" 
                      class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                      :checked="selectedLayerConfig?.toppings?.some(t => t.type === 'flowers')"
                      @change="updateToppingState('flowers', $event.target.checked)">
                    <label class="text-gray-700 font-medium cursor-pointer">Flowers</label>
                  </div>
                  <div v-if="selectedLayerConfig?.toppings?.some(t => t.type === 'flowers')" 
                    class="pl-6 space-y-3">
                    <p class="text-xs text-gray-500">Beautiful edible flowers with colorful petals arranged on your cake</p>
                    
                    <!-- Flower Position Options -->
                    <div class="space-y-2">
                      <label class="text-sm font-medium text-gray-700">Flower Position:</label>
                      <div class="space-y-1">
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="inner" 
                            :checked="!selectedLayerConfig?.flowerPosition || selectedLayerConfig?.flowerPosition === 'inner'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'inner')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Inner (close to center)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="mid" 
                            :checked="selectedLayerConfig?.flowerPosition === 'mid'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'mid')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Mid (middle area)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="outer" 
                            :checked="selectedLayerConfig?.flowerPosition === 'outer'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'outer')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">Outer (near edge)</span>
                        </label>
                        <label class="flex items-center">
                          <input type="radio" 
                            name="flower_position" 
                            value="all" 
                            :checked="selectedLayerConfig?.flowerPosition === 'all'"
                            @change="updateLayerProperty(selectedLayerId, 'flowerPosition', 'all')"
                            class="mr-2 text-[#58091F]">
                          <span class="text-sm text-gray-600">All (full coverage)</span>
                        </label>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Greeting Text -->
          <div class="tab-content" v-show="activeTab === 'tab-greeting'" id="tab-greeting">
            <div class="p-4 space-y-4">
              <div class="flex items-center space-x-2 bg-white rounded-lg p-3 shadow-sm">
                <input type="checkbox" 
                  class="w-4 h-4 text-[#58091F] border-gray-300 rounded focus:ring-[#58091F]" 
                  v-model="greetingConfig.enabled" 
                  @change="onGreetingChange">
                <label class="text-gray-700 font-medium">Enable Greeting Text</label>
              </div>
              
              <div v-if="greetingConfig.enabled" class="space-y-4 bg-white rounded-lg p-4 shadow-sm">
                <div class="space-y-2">
                  <label for="greeting_text" class="block text-sm font-medium text-gray-700">Message:</label>
                  <input type="text" 
                    id="greeting_text" 
                    v-model="greetingConfig.text" 
                    @input="onGreetingChange"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                </div>
                
                <div class="space-y-2">
                  <label for="greeting_color" class="block text-sm font-medium text-gray-700">Text Color:</label>
                  <input type="color" 
                    id="greeting_color" 
                    v-model="greetingConfig.color" 
                    @input="onGreetingChange"
                    class="w-full h-10 p-1 border border-gray-300 rounded-md shadow-sm cursor-pointer">
                </div>
                
                <div class="space-y-2">
                  <label for="greeting_size" class="block text-sm font-medium text-gray-700">
                    Text Size ({{ greetingConfig.size.toFixed(2) }}):
                  </label>
                  <input type="range" 
                    id="greeting_size" 
                    min="0.1" 
                    max="0.8" 
                    step="0.01"
                    v-model.number="greetingConfig.size" 
                    @input="onGreetingChange"
                    class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <div class="space-y-2">
                  <label for="greeting_layout" class="block text-sm font-medium text-gray-700">Layout:</label>
                  <select id="greeting_layout" 
                    v-model="greetingConfig.layout" 
                    @change="onGreetingChange"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:ring-[#58091F] focus:border-[#58091F]">
                    <option value="horizontal-top">Horizontal (On Top, Flat)</option>
                    <option value="circular-top">Circular (On Top, Flat)</option>
                    <option value="vertical-side">Vertical (On Side, Upright)</option>
                  </select>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </ion-content>
  </ion-page>
</template>

<script setup>
import { 
  IonPage, 
  IonHeader, 
  IonToolbar, 
  IonTitle, 
  IonContent,
  IonButtons,
  IonBackButton,
  IonIcon
} from '@ionic/vue';
import { 
  cubeOutline, 
  settingsOutline, 
  constructOutline, 
  layersOutline, 
  flameOutline, 
  iceCreamOutline, 
  sparklesOutline,
  chatbubbleOutline,
  cartOutline
} from 'ionicons/icons';
import { onMounted, onUnmounted, ref, computed, reactive, watch, nextTick } from 'vue';
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
import { FontLoader } from 'three/examples/jsm/loaders/FontLoader.js';
import { TextGeometry } from 'three/examples/jsm/geometries/TextGeometry.js';
import { getDatabase, ref as dbRef, push, set } from '../config/firebase';
import { useRouter } from 'vue-router';

const router = useRouter();

// Add ref for tabs container
const tabsContainer = ref(null);
const activeTab = ref('tab-design');

// Function to scroll to active tab
const scrollToTab = (tabId) => {
  activeTab.value = tabId;
  nextTick(() => {
    const container = tabsContainer.value;
    const activeButton = container?.querySelector(`[data-tab="${tabId}"]`);
    
    if (container && activeButton) {
      const scrollLeft = activeButton.offsetLeft - (container.clientWidth / 2) + (activeButton.clientWidth / 2);
      container.scrollTo({
        left: scrollLeft,
        behavior: 'smooth'
      });
    }
  });
};

let scene, camera, renderer, cakeGroup, controls, cakeStand;
let cakeLayers = ref([]);
let layerIdCounter = 0;
let clock = new THREE.Clock();
let needsCakeRender = false;

// Add history stack for undo functionality
let historyStack = [];
const MAX_HISTORY = 20; // Limit history to prevent memory issues

// Function to save current state to history
const saveToHistory = () => {
  const currentState = {
    cakeLayers: JSON.parse(JSON.stringify(cakeLayers.value)),
    layerIdCounter: layerIdCounter
  };
  
  historyStack.push(currentState);
  
  // Limit history size
  if (historyStack.length > MAX_HISTORY) {
    historyStack.shift();
  }
  
  // Enable/disable undo button
  const undoButton = document.getElementById('undoBtn');
  if (undoButton) {
    undoButton.disabled = historyStack.length === 0;
  }
};

// Function to undo last action
const undoLastAction = () => {
  if (historyStack.length === 0) return;
  
  const previousState = historyStack.pop();
  if (previousState) {
    cakeLayers.value = previousState.cakeLayers;
    layerIdCounter = previousState.layerIdCounter;
    renderCake();
  }
  
  // Update undo button state
  const undoButton = document.getElementById('undoBtn');
  if (undoButton) {
    undoButton.disabled = historyStack.length === 0;
  }
};

let raycaster = new THREE.Raycaster();
let mouse = new THREE.Vector2();
let selectedLayerId = ref(null);
let originalLayerMaterials = new Map();

// Add texture cache for better performance and consistent sizing
let textureCache = new Map();

const defaultLayerSettings = {
  radius: 0.5,
  height: 0.5,
  color: '',
  toppings: [],
  flowerPosition: 'inner', // Default flower position
  roseColor: 'red', // Default rose color
  strawberryPosition: 'inner', // Default strawberry position
  topper: {
    enabled: false,
    type: 'none',
    text: '',
    fontSize: 1,
    color: '#000000',
    style: 'normal',
    position: 'center',
    size: 1,
    stickHeight: 0.4
  },
  edgeIcing: {
    enabled: false,
    style: 'smooth',
    color: '#FFFFFF',
    thickness: 0.05,
    isAnimating: false,
    animationProgress: 0,
    animationSpeed: 0.5
  },
  bottomIcing: {
    enabled: false,
    style: 'smooth',
    color: '#FFFFFF',
    thickness: 0.05,
    isAnimating: false,
    animationProgress: 0,
    animationSpeed: 0.5
  }
};

// Move sizeOptions above selectedSize
const oneTierSizeOptions = [
  { name: "6″ × 6″", diameter: 6, height: 6, price: 999 },
  { name: "6″ × 7″", diameter: 6, height: 7, price: 1299 },
  { name: "6″ × 8″", diameter: 6, height: 8, price: 1649 },
  { name: "6″ × 9″", diameter: 6, height: 9, price: 1949 },
  { name: "6″ × 10″", diameter: 6, height: 10, price: 2399 }
];

const twoTierSizeOptions = [
  {
    name: "4 x 5 & 6 x 5", diameter: [
      {
        diameter: 4,
        height: 5,
      },
      {
      
        diameter: 6,
        height: 5,
      },
    ],
    price: 2199
  },
  {
    name: "5 x 5 & 7 x 5", diameter: [
      {
        diameter: 5,
        height: 5,
       
      },
      {
        diameter: 7,
        height: 5,
     
      }
    ],
    price: 2399
  },
  {
    name: "6 x 5 & 8 x 5", diameter: [
      {
        diameter: 6,
        height: 5,
       
      },
      {
        diameter: 8,
        height: 5,
     
      }
    ],
    price: 2599
  },
      {
        name: "7 x 5 & 9 x 5", diameter: [
          {
            diameter: 7,
            height: 5,
          
          },
          {
            diameter: 9,
            height: 5,
        
          }
        ],
        price: 2799
      },
      {
        name: "8 x 5 & 10 x 5", diameter: [
          {
            diameter: 8,
            height: 5,
          
          },
          {
            diameter: 10,
            height: 5,
        
          }
        ],
        price: 3399
      },
      {
        name: "9 x 5 & 11 x 5", diameter: [
          {
            diameter: 9,
            height: 5,
          
          },
          {
            diameter: 11,
            height: 5,
        
          }
        ],
        price: 3999
      },
  
];

const threeTierSizeOptions = [
  {
    name: "4 x 5 & 6 x 5 & 8 x 5", diameter: [
      {
        diameter: 4,
        height: 5,
      },
      {

        diameter: 6,
        height: 5,
      },
      {
        diameter: 8,
        height: 5,
      },
    ],
    price: 3299
  },
  {
    name: "5 x 5 & 7 x 5 & 9 x 5", diameter: [
      {
        diameter: 5,
        height: 5,
      },
      {

        diameter: 7,
        height: 5,
      },
      {
        diameter: 9,
        height: 5,
      },
    ],
    price: 3599
  },
  {
    name: "6 x 5 & 8 x 5 & 10 x 5", diameter: [
      {
        diameter: 6,
        height: 5,
      },
      {

        diameter: 8,
        height: 5,
      },
      {
        diameter: 10,
        height: 5,
      },
    ],
    price: 4399
  },
  {
    name: "7 x 5 & 9 x 5 & 11 x 5", diameter: [
      {
        diameter: 7,
        height: 5,
      },
      {

        diameter: 9,
        height: 5,
      },
      {
        diameter: 11,
        height: 5,
      },
    ],
    price: 5799
  },

];

// Define computed sizeOptions based on the selected number of layers
const sizeOptions = computed(() => {
  switch (selectedLayers.value) {
    case 1:
      return oneTierSizeOptions;
    case 2:
      return twoTierSizeOptions;
    case 3:
      return threeTierSizeOptions;
    default:
      return oneTierSizeOptions;
  }
});

const flavorOptions = [
  { 
    name: 'Chocolate',
    description: 'Rich and decadent chocolate flavor',
    color: '#4A2C2A'
  },
  { 
    name: 'Ube',
    description: 'Traditional Filipino purple yam flavor',
    color: '#8A2BE2'
  },
  { 
    name: 'Vanilla',
    description: 'Classic and versatile vanilla flavor',
    color: '#F5F5DC'
  },
  { 
    name: 'Mocha',
    description: 'Perfect blend of coffee and chocolate',
    color: '#6F4E37'
  },
  { 
    name: 'Strawberry',
    description: 'Sweet and fruity strawberry flavor',
    color: '#FFB6C1'
  }
];

const showSelectionsModal = ref(true);
const currentStep = ref(1);
const selectedLayers = ref(1);
const selectedSize = ref(null);
const selectedFlavor = ref(null);
const showResetConfirmModal = ref(false);

// Computed property to check if user can proceed to next step
const canProceed = computed(() => {
  switch (currentStep.value) {
    case 1:
      return selectedLayers.value !== null;
    case 2:
      return selectedSize.value !== null;
    case 3:
      return selectedFlavor.value !== null;
    default:
      return false;
  }
});

// Adjust cake stand to be proportional to the cake
const createCakeStand = (cakeDiameter = 6) => {
  const standGroup = new THREE.Group();
  const baseRadius = (cakeDiameter + 1) / 2; // 1 inch larger than cake
  const baseHeight = 0.5; // Increased base height
  const baseGeometry = new THREE.CylinderGeometry(baseRadius, baseRadius, baseHeight, 32);
  const baseMaterial = new THREE.MeshStandardMaterial({
    color: 0xCCCCCC,
    roughness: 0.7,
    metalness: 0.3
  });
  const base = new THREE.Mesh(baseGeometry, baseMaterial);
  base.position.y = -baseHeight / 2;
  standGroup.add(base);

  const pillarRadius = 0.2;
  const pillarHeight = 2.5; // Increased pillar height
  const pillarGeometry = new THREE.CylinderGeometry(pillarRadius, pillarRadius, pillarHeight, 16);
  const pillarMaterial = new THREE.MeshStandardMaterial({
    color: 0xCCCCCC,
    roughness: 0.7,
    metalness: 0.3
  });
  const pillar = new THREE.Mesh(pillarGeometry, pillarMaterial);
  pillar.position.y = pillarHeight / 2;
  standGroup.add(pillar);

  const topRadius = (cakeDiameter + 0.5) / 2; // Slightly larger than cake
  const topHeight = 0.05;
  const topGeometry = new THREE.CylinderGeometry(topRadius, topRadius, topHeight, 32);
  const topMaterial = new THREE.MeshStandardMaterial({
    color: 0xCCCCCC,
    roughness: 0.7,
    metalness: 0.3
  });
  const top = new THREE.Mesh(topGeometry, topMaterial);
  top.position.y = pillarHeight + topHeight / 2;
  standGroup.add(top);

  standGroup.userData.totalHeight = baseHeight + pillarHeight + topHeight;
  return standGroup;
};

onMounted(() => {
  initScene();
});

onUnmounted(() => {
  if (renderer) {
    renderer.dispose();
  }
  if (scene) {
    scene.traverse((object) => {
      if (object.geometry) {
        object.geometry.dispose();
      }
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
          object.material.dispose();
        }
      }
    });
  }
  window.removeEventListener('resize', onWindowResize);
});

const initScene = () => {
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf0f4f8);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  
  // Set initial camera position (closer to the scene)
  camera.position.set(0, 0, 20);
  camera.lookAt(0, 0, 0);
  
  const canvas = document.getElementById('cakeCanvas');
  renderer = new THREE.WebGLRenderer({
    canvas: canvas,
    antialias: true
  });
  renderer.setSize(window.innerWidth, window.innerHeight);
  
  // Add lights
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
  scene.add(ambientLight);
  
  const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
  directionalLight.position.set(10, 20, 5);
  directionalLight.castShadow = true;
  directionalLight.shadow.mapSize.width = 1024;
  directionalLight.shadow.mapSize.height = 1024;
  scene.add(directionalLight);
  
  // Create and position the cake stand (use default 6 if not available)
  cakeStand = createCakeStand(selectedSize.value ? selectedSize.value.diameter : 6);
  cakeStand.position.y = 0;
  scene.add(cakeStand);
  
  // Add ground grid for reference
  const gridHelper = new THREE.GridHelper(30, 30, 0x888888, 0xcccccc);
  gridHelper.position.y = -0.01;
  scene.add(gridHelper);
  
  // Setup controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;
  controls.dampingFactor = 0.1;
  controls.minDistance = 2;
  controls.maxDistance = 100;
  controls.maxPolarAngle = Math.PI / 2 + 0.1;
  
  cakeGroup = new THREE.Group();
  scene.add(cakeGroup);

  initTabs();
  // document.getElementById('addLayerBtn').addEventListener('click', addNewLayerAndSelect);
  document.getElementById('saveCakeBtn').addEventListener('click', saveCakeConfiguration);
  document.getElementById('loadCakeInput').addEventListener('change', loadCakeConfiguration);
  // document.getElementById('resetCakeBtn').addEventListener('click', resetCakeDesign);
  // document.getElementById('undoBtn').addEventListener('click', undoLastAction);

  window.addEventListener('resize', onWindowResize, false);
  renderer.domElement.addEventListener('click', onCanvasClick, false);

  addNewLayerAndSelect();
  startAnimationLoop();
};

const initTabs = () => {
  const tabButtons = document.querySelectorAll('.tab-button');
  const tabContents = document.querySelectorAll('.tab-content');

  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      tabButtons.forEach(btn => btn.classList.remove('active'));
      tabContents.forEach(content => content.classList.remove('active'));
      button.classList.add('active');
      const targetTabId = button.getAttribute('data-tab');
      document.getElementById(targetTabId).classList.add('active');
      
      // Update controls based on selected layer and active tab
      if (selectedLayerId.value) {
        switch (targetTabId) {
          case 'tab-layer-editor':
            updateControlsForSelectedLayer();
            break;
          case 'tab-topper':
            // updateControlsForSelectedTopper(); // Commented out - now using template-based UI
            break;
          case 'tab-icing':
            // updateControlsForSelectedIcing(); // Commented out - now using template-based UI
            break;
          case 'tab-toppings':
            // updateControlsForSelectedToppings(); // Commented out - now using template-based UI
            break;
        }
      }
    });
  });
  
  if (tabButtons.length > 0) {
    tabButtons[0].click();
  }
};

const onCanvasClick = (event) => {
  event.preventDefault();
  
  // Safety check to ensure cakeGroup is initialized
  if (!cakeGroup) {
    console.warn('cakeGroup not initialized yet, skipping click handling');
    return;
  }
  
  mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
  mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(cakeGroup.children.filter(child => child.userData.isCakeLayer));
  if (intersects.length > 0) {
    const clickedLayerObject = intersects[0].object;
    if (clickedLayerObject.userData.layerId) {
      selectLayer(clickedLayerObject.userData.layerId);
      // Get the active tab
      const activeTab = document.querySelector('.tab-button.active');
      if (activeTab) {
        const tabId = activeTab.getAttribute('data-tab');
        switch (tabId) {
          case 'tab-layer-editor':
            updateControlsForSelectedLayer();
            break;
          case 'tab-topper':
            // updateControlsForSelectedTopper(); // Commented out - now using template-based UI
            break;
          case 'tab-icing':
            // updateControlsForSelectedIcing(); // Commented out - now using template-based UI
            break;
          case 'tab-toppings':
            // updateControlsForSelectedToppings(); // Commented out - now using template-based UI
            break;
        }
      }
    }
  } else {
    selectLayer(null);
  }
};

const selectLayer = (layerId) => {
  // Safety check to ensure cakeGroup is initialized
  if (!cakeGroup) {
    console.warn('cakeGroup not initialized yet, skipping layer selection');
    selectedLayerId.value = layerId; // Still update the selected layer ID
    return;
  }
  
  if (selectedLayerId.value) {
    const previousLayerMesh = cakeGroup.children.find(
      (child) => child.userData.layerId === selectedLayerId.value
    );
    if (previousLayerMesh && originalLayerMaterials.has(selectedLayerId.value)) {
      previousLayerMesh.material = originalLayerMaterials.get(selectedLayerId.value);
      originalLayerMaterials.delete(selectedLayerId.value);
    }
  }
  selectedLayerId.value = layerId;
  if (selectedLayerId.value) {
    const currentLayerMesh = cakeGroup.children.find(
      (child) => child.userData.layerId === selectedLayerId.value
    );
    if (currentLayerMesh) {
      if (!originalLayerMaterials.has(selectedLayerId.value)) {
        originalLayerMaterials.set(selectedLayerId.value, currentLayerMesh.material);
      }
      // The following lines that change the emissive color have been removed:
      // currentLayerMesh.material = currentLayerMesh.material.clone();
      // currentLayerMesh.material.emissive.setHex(0x555555);
    }
  }
  updateControlsForSelectedLayer();
  renderCake();
};


const createLayerMesh = (radius, height, color, layerId) => {
  const geometry = new THREE.CylinderGeometry(radius, radius, height, 64);
  const material = new THREE.MeshStandardMaterial({
    color: color,
    roughness: 0.7,
    metalness: 0.1
  });
  const layerMesh = new THREE.Mesh(geometry, material);
  layerMesh.userData.isCakeLayer = true;
  layerMesh.userData.layerId = layerId;
  return layerMesh;
};

// Load the font once and reuse it
let loadedFont = null;
const fontLoader = new FontLoader();
fontLoader.load('https://cdn.jsdelivr.net/npm/three@0.164.1/examples/fonts/helvetiker_regular.typeface.json', (font) => {
  loadedFont = font;
  console.log('Font loaded:', loadedFont);
  // Only call renderCake if the scene is fully initialized
  if (typeof renderCake === 'function' && cakeGroup && scene && renderer) {
    console.log('Triggering renderCake after font load');
    renderCake();
  }
});

// Performance optimization: Cache geometry to avoid recreation
let geometryCache = new Map();

// Global helper function to dispose of geometries and materials
const disposeObject = (object) => {
  if (object.isMesh) {
    if (object.geometry && object.geometry.dispose) {
      object.geometry.dispose();
    }
    if (object.material) {
      if (Array.isArray(object.material)) {
        object.material.forEach(material => material.dispose());
      } else {
        if (object.material && object.material.dispose) {
          object.material.dispose();
        }
      }
    }
  }
  if (object.children) {
    object.children.forEach(child => disposeObject(child));
  }
};

const addDecorations = (layerMesh, layerConfig) => {
  const {
    radius: layerRadius,
    height: layerHeight,
    toppings,
    topper,
    edgeIcing,
    bottomIcing
  } = layerConfig;
  const topY = layerHeight / 2;
  const bottomY = -layerHeight / 2;

  // Remove existing decorations
  const existingEdgeIcing = layerMesh.getObjectByName("edgeIcingGroup");
  if (existingEdgeIcing) {
    disposeObject(existingEdgeIcing);
    layerMesh.remove(existingEdgeIcing);
  }
  const existingToppings = layerMesh.getObjectByName("toppingGroup");
  if (existingToppings) {
    disposeObject(existingToppings);
    layerMesh.remove(existingToppings);
  }
  const existingTopper = layerMesh.getObjectByName("topperGroup");
  if (existingTopper) {
    disposeObject(existingTopper);
    layerMesh.remove(existingTopper);
  }

  // Add topper if enabled
  if (topper && topper.enabled) {
    const topperGroup = new THREE.Group();
    topperGroup.name = "topperGroup";

    // --- DYNAMIC STICK LOGIC ---
    // Default values
    let stickHeight = topper.stickHeight || 0.4; // Use custom stick height or default
    if (stickHeight < 0.1) stickHeight = 0.1;
    
    // Check if this is the top layer in the cake to avoid intersections
    const currentLayerIndex = cakeLayers.value.findIndex(layer => layer.id === layerConfig.id);
    const isTopLayer = currentLayerIndex === cakeLayers.value.length - 1;
    
    // If it's not the top layer, we need to adjust the stick height to avoid intersections
    if (!isTopLayer) {
      // Calculate maximum safe height to avoid intersection with layer above
      // Get distance to the bottom of the layer above
      const layersAbove = cakeLayers.value.slice(currentLayerIndex + 1);
      const nextLayerHeight = layersAbove.reduce((total, layer) => total + layer.height, 0);
      
      // Calculate safe distance (leaving a small gap)
      const safeDistance = nextLayerHeight - 0.05;
      
      // Limit stick height to prevent intersection
      if (stickHeight > safeDistance) {
        stickHeight = Math.max(0.1, safeDistance);
      }
    }
    
    let stickBaseY = topY; // Always start at cake top
    let stickTopY = stickBaseY + stickHeight; // Calculate the top of the stick
    
    // Calculate content position offsets based on stick height
    let textYOffset = 0.05; // Small offset from stick top
    // Increase the image offset to prevent overlap with the stick
    let imageYOffset = 0.15;
    
    // Calculate topper base position
    let topperY = topY;
    let topperX = 0;
    let topperZ = 0;
    
    if (topper.position === 'top') {
      topperY += 0.1; // Slightly above the layer
      stickBaseY = topperY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'bottom') {
      topperY = bottomY - 0.1; // Slightly below the layer
      stickBaseY = topperY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'front') {
      topperZ = layerRadius * 0.6; // Move towards front
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'back') {
      topperZ = -layerRadius * 0.6; // Move towards back
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'left') {
      topperX = -layerRadius * 0.6; // Move towards left
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'right') {
      topperX = layerRadius * 0.6; // Move towards right
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'front-left') {
      topperX = -layerRadius * 0.4; // Move towards front-left
      topperZ = layerRadius * 0.4;
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'front-right') {
      topperX = layerRadius * 0.4; // Move towards front-right
      topperZ = layerRadius * 0.4;
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'back-left') {
      topperX = -layerRadius * 0.4; // Move towards back-left
      topperZ = -layerRadius * 0.4;
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else if (topper.position === 'back-right') {
      topperX = layerRadius * 0.4; // Move towards back-right
      topperZ = -layerRadius * 0.4;
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    } else {
      // Default center position
      stickBaseY = topY;
      stickTopY = stickBaseY + stickHeight;
    }

    // Add stick/support for the topper
    const stickGeometry = new THREE.CylinderGeometry(0.02, 0.02, stickHeight, 8);
    const stickMaterial = new THREE.MeshStandardMaterial({
      color: 0xCCCCCC,
      roughness: 0.7,
      metalness: 0.3
    });
    const stick = new THREE.Mesh(stickGeometry, stickMaterial);
    stick.position.set(topperX, stickBaseY + stickHeight / 2, topperZ); // Use calculated position
    topperGroup.add(stick);

    // Add a small base for the stick
    const baseGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 8);
    const baseMaterial = new THREE.MeshStandardMaterial({
      color: 0xCCCCCC,
      roughness: 0.7,
      metalness: 0.3
    });
    const base = new THREE.Mesh(baseGeometry, baseMaterial);
    base.position.set(topperX, stickBaseY - 0.01, topperZ); // Use calculated position
    topperGroup.add(base);

    // Only create topper text if font is loaded
    if (topper.type === 'text') {
      if (!loadedFont) {
        console.warn('Font not loaded yet, skipping topper text creation');
        return;
      }
      if (topper.text && topper.text.trim().length > 0) {
        const topperText = topper.text.trim();
        const sizeMultiplier = topper.size || 1;
        const textGeometry = new TextGeometry(topperText, {
          font: loadedFont,
          size: 0.12 * topper.fontSize * sizeMultiplier,
          height: 0.02 * sizeMultiplier,
          curveSegments: 4,
          bevelEnabled: false
        });
        textGeometry.computeBoundingBox();
        const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
        textGeometry.translate(-textWidth / 2, 0, 0); // Center horizontally
        const textMaterial = new THREE.MeshStandardMaterial({
          color: topper.color,
          roughness: 0.7,
          metalness: 0.1
        });
        const textMesh = new THREE.Mesh(textGeometry, textMaterial);
        textMesh.position.set(topperX, stickTopY + textYOffset, topperZ); // Use calculated position
        topperGroup.add(textMesh);
      }
    }
    // Handle backward compatibility: if type is text_image, treat as image
    else if ((topper.type === 'image' || topper.type === 'text_image') && topper.image) {
      const sizeMultiplier = topper.size || 1;
      
      // Check if texture is already cached
      if (textureCache.has(topper.image)) {
        // Use cached texture for immediate rendering
        const cachedTexture = textureCache.get(topper.image);
        const imageGeometry = new THREE.PlaneGeometry(0.5 * sizeMultiplier, 0.5 * sizeMultiplier);
        const imageMaterial = new THREE.MeshStandardMaterial({
          map: cachedTexture,
          side: THREE.DoubleSide,
          transparent: true
        });
        const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
        
        // Calculate half height of the image to position it properly
        const imageHeight = 0.5 * sizeMultiplier;
        const halfImageHeight = imageHeight / 2;
        
        // Position image with proper offset to avoid overlap with stick
        imageMesh.position.set(topperX, stickTopY + imageYOffset + halfImageHeight, topperZ);
        imageMesh.name = "topperImage";
        topperGroup.add(imageMesh);
      } else {
        // Load texture and cache it
        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load(
          topper.image, 
          (texture) => {
            // Cache the texture for future use
            textureCache.set(topper.image, texture);
            
            // Create image geometry with current size
            const imageGeometry = new THREE.PlaneGeometry(0.5 * sizeMultiplier, 0.5 * sizeMultiplier);
            const imageMaterial = new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.DoubleSide,
              transparent: true
            });
            const imageMesh = new THREE.Mesh(imageGeometry, imageMaterial);
            
            // Calculate half height of the image to position it properly
            const imageHeight = 0.5 * sizeMultiplier;
            const halfImageHeight = imageHeight / 2;
            
            // Position image with proper offset to avoid overlap with stick
            imageMesh.position.set(topperX, stickTopY + imageYOffset + halfImageHeight, topperZ);
            imageMesh.name = "topperImage";
            topperGroup.add(imageMesh);
            
            // Force a render update after the texture is loaded
            if (renderer && scene && camera) {
              renderer.render(scene, camera);
            }
          },
          (progress) => {
            // Optional: Handle loading progress
            console.log('Topper image loading progress:', (progress.loaded / progress.total * 100) + '%');
          },
          (error) => {
            console.error('Error loading topper image:', error);
          }
        );
      }
    }

    // Add a small connector between stick and content
    const connectorGeometry = new THREE.CylinderGeometry(0.04, 0.03, 0.05, 12);
    const connectorMaterial = new THREE.MeshStandardMaterial({
      color: 0xCCCCCC,
      roughness: 0.7,
      metalness: 0.3
    });
    const connector = new THREE.Mesh(connectorGeometry, connectorMaterial);
    
    // Position connector slightly higher than the top of the stick to create a gentle transition
    connector.position.set(topperX, stickTopY + 0.02, topperZ); // Use calculated position
    topperGroup.add(connector);

    layerMesh.add(topperGroup);
  }

  // Add existing decorations
  if (edgeIcing.enabled) {
    const icingGroup = new THREE.Group();
    icingGroup.name = "edgeIcingGroup";
    const icingMaterial = new THREE.MeshStandardMaterial({
      color: edgeIcing.color,
      roughness: 0.6,
      metalness: 0.1
    });
    if (edgeIcing.style === 'smooth') {
      let angle = edgeIcing.isAnimating ? edgeIcing.animationProgress * Math.PI * 2 : Math.PI * 2;
      angle = Math.max(0.001, angle);
      const tube = edgeIcing.thickness;
      const radius = layerRadius - tube;
      if (radius > 0) {
        const geo = new THREE.TorusGeometry(radius, tube, 24, 64, angle);
        const mesh = new THREE.Mesh(geo, icingMaterial);
        mesh.position.y = topY;
        mesh.rotation.x = Math.PI / 2;
        icingGroup.add(mesh);
      }
    } else if (edgeIcing.style === 'curl') {
      const curlR = edgeIcing.thickness * 0.8;
      // Calculate number of curls based on circumference with overlap
      const circumference = Math.PI * 2 * (layerRadius - curlR);
      // Increase number of curls to ensure no gaps
      const numTotal = Math.max(1, Math.floor(circumference / (curlR * 1.2)));
      let numShow = edgeIcing.isAnimating ? Math.floor(edgeIcing.animationProgress * numTotal) : numTotal;

      // Create a group for all curls
      const curlGroup = new THREE.Group();
      
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Add variation to curl size (smaller range to maintain consistency)
        const sizeVariation = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
        const curlSize = curlR * sizeVariation;
        
        // Create the main curl
        const curlGeo = new THREE.SphereGeometry(curlSize, 12, 8);
        const curl = new THREE.Mesh(curlGeo, icingMaterial);
        
        // Position with minimal randomness to maintain continuity
        const radiusVariation = (Math.random() - 0.5) * 0.05; // -0.025 to 0.025
        const heightVariation = (Math.random() - 0.5) * 0.05; // -0.025 to 0.025
        const angleVariation = (Math.random() - 0.5) * 0.1; // -0.05 to 0.05
        
        // Calculate position with minimal variations
        const curlRadius = layerRadius - curlSize * 0.7 + radiusVariation;
        const curlX = Math.cos(ang + angleVariation) * curlRadius;
        const curlZ = Math.sin(ang + angleVariation) * curlRadius;
        const curlY = topY + curlSize * 0.3 + heightVariation;
        
        curl.position.set(curlX, curlY, curlZ);
        
        // Add minimal tilt to maintain continuity
        curl.rotation.x = (Math.random() - 0.5) * 0.2;
        curl.rotation.z = (Math.random() - 0.5) * 0.2;
        
        // Add a connecting "tail" to make it look more continuous
        const tailGeo = new THREE.ConeGeometry(curlSize * 0.6, curlSize * 1.2, 8);
        const tail = new THREE.Mesh(tailGeo, icingMaterial);
        tail.position.y = -curlSize * 0.6;
        tail.rotation.x = Math.PI / 2;
        curl.add(tail);
        
        curlGroup.add(curl);
      }
      
      icingGroup.add(curlGroup);
    } else if (edgeIcing.style === 'shell') {
      const shellR = edgeIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - shellR);
      const numTotal = Math.max(1, Math.floor(circumference / (shellR * 1.2)));
      let numShow = edgeIcing.isAnimating ? Math.floor(edgeIcing.animationProgress * numTotal) : numTotal;

      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Create shell shape using multiple spheres
        const shellGroup = new THREE.Group();
        
        // Main shell body
        const mainShell = new THREE.Mesh(
          new THREE.SphereGeometry(shellR, 12, 8),
          icingMaterial
        );
        
        // Shell tail
        const tail = new THREE.Mesh(
          new THREE.ConeGeometry(shellR * 0.6, shellR * 1.5, 8),
          icingMaterial
        );
        tail.position.y = -shellR * 0.75;
        tail.rotation.x = Math.PI / 2;
        
        shellGroup.add(mainShell);
        shellGroup.add(tail);
        
        // Position and rotate
        const shellRadius = layerRadius - shellR * 0.7;
        shellGroup.position.set(
          Math.cos(ang) * shellRadius,
          topY + shellR * 0.3,
          Math.sin(ang) * shellRadius
        );
        shellGroup.rotation.y = -ang;
        
        icingGroup.add(shellGroup);
      }
    } else if (edgeIcing.style === 'rosette') {
      const rosetteR = edgeIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - rosetteR);
      const numTotal = Math.max(1, Math.floor(circumference / (rosetteR * 2)));
      let numShow = edgeIcing.isAnimating ? Math.floor(edgeIcing.animationProgress * numTotal) : numTotal;

      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Create rosette using multiple petals
        const rosetteGroup = new THREE.Group();
        const numPetals = 5;
        
        for (let j = 0; j < numPetals; j++) {
          const petalAng = (j / numPetals) * Math.PI * 2;
          const petal = new THREE.Mesh(
            new THREE.SphereGeometry(rosetteR * 0.6, 8, 8),
            icingMaterial
          );
          
          petal.position.set(
            Math.cos(petalAng) * rosetteR * 0.5,
            Math.sin(petalAng) * rosetteR * 0.5,
            0
          );
          rosetteGroup.add(petal);
        }
        
        // Center of rosette
        const center = new THREE.Mesh(
          new THREE.SphereGeometry(rosetteR * 0.4, 8, 8),
          icingMaterial
        );
        rosetteGroup.add(center);
        
        // Position and rotate
        const rosetteRadius = layerRadius - rosetteR;
        rosetteGroup.position.set(
          Math.cos(ang) * rosetteRadius,
          topY + rosetteR * 0.5,
          Math.sin(ang) * rosetteRadius
        );
        rosetteGroup.rotation.y = -ang;
        
        icingGroup.add(rosetteGroup);
      }
    } else if (edgeIcing.style === 'ruffle') {
      const ruffleR = edgeIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - ruffleR);
      const numTotal = Math.max(1, Math.floor(circumference / (ruffleR * 1.5)));
      let numShow = edgeIcing.isAnimating ? Math.floor(edgeIcing.animationProgress * numTotal) : numTotal;

      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Create ruffle segment
        const ruffleGroup = new THREE.Group();
        
        // Main ruffle part
        const ruffle = new THREE.Mesh(
          new THREE.SphereGeometry(ruffleR, 12, 8),
          icingMaterial
        );
        
        // Ruffle wave
        const wave = new THREE.Mesh(
          new THREE.TorusGeometry(ruffleR * 0.8, ruffleR * 0.3, 8, 16, Math.PI),
          icingMaterial
        );
        wave.rotation.x = Math.PI / 2;
        wave.position.y = -ruffleR * 0.5;
        
        ruffleGroup.add(ruffle);
        ruffleGroup.add(wave);
        
        // Position and rotate
        const ruffleRadius = layerRadius - ruffleR * 0.7;
        ruffleGroup.position.set(
          Math.cos(ang) * ruffleRadius,
          topY + ruffleR * 0.3,
          Math.sin(ang) * ruffleRadius
        );
        ruffleGroup.rotation.y = -ang;
        
        icingGroup.add(ruffleGroup);
      }
    } else if (edgeIcing.style === 'zigzag') {
      const zigzagR = edgeIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - zigzagR);
      const numTotal = Math.max(1, Math.floor(circumference / (zigzagR * 1.5)));
      let numShow = edgeIcing.isAnimating ? Math.floor(edgeIcing.animationProgress * numTotal) : numTotal;

      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Create zigzag segment
        const zigzagGroup = new THREE.Group();
        
        // Main point
        const point = new THREE.Mesh(
          new THREE.ConeGeometry(zigzagR * 0.8, zigzagR * 1.5, 4),
          icingMaterial
        );
        point.rotation.x = -Math.PI / 2; // Point downward for bottom icing
        
        // Base
        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(zigzagR * 0.6, zigzagR * 0.6, zigzagR * 0.3, 4),
          icingMaterial
        );
        base.position.y = zigzagR * 0.9; // Position above downward-pointing zigzag
        
        zigzagGroup.add(point);
        zigzagGroup.add(base);
        
        // Position and rotate
        const zigzagRadius = layerRadius - zigzagR * 0.7;
        zigzagGroup.position.set(
          Math.cos(ang) * zigzagRadius,
          topY + zigzagR * 0.3,
          Math.sin(ang) * zigzagRadius
        );
        zigzagGroup.rotation.y = -ang;
        
        icingGroup.add(zigzagGroup);
      }
    }
    if (icingGroup.children.length > 0) layerMesh.add(icingGroup);
  }

  if (bottomIcing.enabled) {
    const bottomIcingGroup = new THREE.Group();
    bottomIcingGroup.name = "bottomIcingGroup";
    const bottomIcingMaterial = new THREE.MeshStandardMaterial({
      color: bottomIcing.color,
      roughness: 0.6,
      metalness: 0.1
    });
    if (bottomIcing.style === 'smooth') {
      let angle = bottomIcing.isAnimating ? bottomIcing.animationProgress * Math.PI * 2 : Math.PI * 2;
      angle = Math.max(0.001, angle);
      const tube = bottomIcing.thickness;
      const radius = layerRadius - tube;
      if (radius > 0) {
        const geo = new THREE.TorusGeometry(radius, tube, 24, 64, angle);
        const mesh = new THREE.Mesh(geo, bottomIcingMaterial);
        mesh.position.y = bottomY;
        mesh.rotation.x = Math.PI / 2;
        bottomIcingGroup.add(mesh);
      }
    } else if (bottomIcing.style === 'curl') {
      const curlR = bottomIcing.thickness * 0.8;
      // Calculate number of curls based on circumference with overlap
      const circumference = Math.PI * 2 * (layerRadius - curlR);
      // Increase number of curls to ensure no gaps
      const numTotal = Math.max(1, Math.floor(circumference / (curlR * 1.2)));
      let numShow = bottomIcing.isAnimating ? Math.floor(bottomIcing.animationProgress * numTotal) : numTotal;

      // Create a group for all curls
      const curlGroup = new THREE.Group();
      
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        
        // Add variation to curl size (smaller range to maintain consistency)
        const sizeVariation = 0.9 + Math.random() * 0.2; // 0.9 to 1.1
        const curlSize = curlR * sizeVariation;
        
        // Create the main curl
        const curlGeo = new THREE.SphereGeometry(curlSize, 12, 8);
        const curl = new THREE.Mesh(curlGeo, bottomIcingMaterial);
        
        // Position with minimal randomness to maintain continuity
        const radiusVariation = (Math.random() - 0.5) * 0.05; // -0.025 to 0.025
        const heightVariation = (Math.random() - 0.5) * 0.05; // -0.025 to 0.025
        const angleVariation = (Math.random() - 0.5) * 0.1; // -0.05 to 0.05
        
        // Calculate position with minimal variations
        const curlRadius = layerRadius - curlSize * 0.7 + radiusVariation;
        const curlX = Math.cos(ang + angleVariation) * curlRadius;
        const curlZ = Math.sin(ang + angleVariation) * curlRadius;
        const curlY = bottomY - curlSize * 0.3 + heightVariation; // Position at bottom
        
        curl.position.set(curlX, curlY, curlZ);
        
        // Add minimal tilt to maintain continuity
        curl.rotation.x = (Math.random() - 0.5) * 0.2;
        curl.rotation.z = (Math.random() - 0.5) * 0.2;
        
        // Add a connecting "tail" to make it look more continuous
        const tailGeo = new THREE.ConeGeometry(curlSize * 0.6, curlSize * 1.2, 8);
        const tail = new THREE.Mesh(tailGeo, bottomIcingMaterial);
        tail.position.y = curlSize * 0.6; // Flip direction for bottom
        tail.rotation.x = -Math.PI / 2; // Flip rotation for bottom
        curl.add(tail);
        
        curlGroup.add(curl);
      }
      
      bottomIcingGroup.add(curlGroup);
    } else if (bottomIcing.style === 'shell') {
      const shellR = bottomIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - shellR);
      const numTotal = Math.max(1, Math.floor(circumference / (shellR * 1.2)));
      let numShow = bottomIcing.isAnimating ? Math.floor(bottomIcing.animationProgress * numTotal) : numTotal;
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        const shellGroup = new THREE.Group();
        const mainShell = new THREE.Mesh(
          new THREE.SphereGeometry(shellR, 12, 8),
          bottomIcingMaterial
        );
        const tail = new THREE.Mesh(
          new THREE.ConeGeometry(shellR * 0.6, shellR * 1.5, 8),
          bottomIcingMaterial
        );
        tail.position.y = -shellR * 0.75;
        tail.rotation.x = Math.PI / 2;
        shellGroup.add(mainShell);
        shellGroup.add(tail);
        const shellRadius = layerRadius - shellR * 0.7;
        shellGroup.position.set(
          Math.cos(ang) * shellRadius,
          bottomY - shellR * 0.3,
          Math.sin(ang) * shellRadius
        );
        shellGroup.rotation.y = -ang;
        bottomIcingGroup.add(shellGroup);
      }
    } else if (bottomIcing.style === 'rosette') {
      const rosetteR = bottomIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - rosetteR);
      const numTotal = Math.max(1, Math.floor(circumference / (rosetteR * 2)));
      let numShow = bottomIcing.isAnimating ? Math.floor(bottomIcing.animationProgress * numTotal) : numTotal;
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        const rosetteGroup = new THREE.Group();
        const numPetals = 5;
        for (let j = 0; j < numPetals; j++) {
          const petalAng = (j / numPetals) * Math.PI * 2;
          const petal = new THREE.Mesh(
            new THREE.SphereGeometry(rosetteR * 0.6, 8, 8),
            bottomIcingMaterial
          );
          petal.position.set(
            Math.cos(petalAng) * rosetteR * 0.5,
            Math.sin(petalAng) * rosetteR * 0.5,
            0
          );
          rosetteGroup.add(petal);
        }
        const center = new THREE.Mesh(
          new THREE.SphereGeometry(rosetteR * 0.4, 8, 8),
          bottomIcingMaterial
        );
        rosetteGroup.add(center);
        const rosetteRadius = layerRadius - rosetteR;
        rosetteGroup.position.set(
          Math.cos(ang) * rosetteRadius,
          bottomY - rosetteR * 0.5,
          Math.sin(ang) * rosetteRadius
        );
        rosetteGroup.rotation.y = -ang;
        bottomIcingGroup.add(rosetteGroup);
      }
    } else if (bottomIcing.style === 'ruffle') {
      const ruffleR = bottomIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - ruffleR);
      const numTotal = Math.max(1, Math.floor(circumference / (ruffleR * 1.5)));
      let numShow = bottomIcing.isAnimating ? Math.floor(bottomIcing.animationProgress * numTotal) : numTotal;
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        const ruffleGroup = new THREE.Group();
        const ruffle = new THREE.Mesh(
          new THREE.SphereGeometry(ruffleR, 12, 8),
          bottomIcingMaterial
        );
        const wave = new THREE.Mesh(
          new THREE.TorusGeometry(ruffleR * 0.8, ruffleR * 0.3, 8, 16, Math.PI),
          bottomIcingMaterial
        );
        wave.rotation.x = Math.PI / 2;
        wave.position.y = -ruffleR * 0.5;
        ruffleGroup.add(ruffle);
        ruffleGroup.add(wave);
        const ruffleRadius = layerRadius - ruffleR * 0.7;
        ruffleGroup.position.set(
          Math.cos(ang) * ruffleRadius,
          bottomY - ruffleR * 0.3,
          Math.sin(ang) * ruffleRadius
        );
        ruffleGroup.rotation.y = -ang;
        bottomIcingGroup.add(ruffleGroup);
      }
    } else if (bottomIcing.style === 'zigzag') {
      const zigzagR = bottomIcing.thickness * 0.8;
      const circumference = Math.PI * 2 * (layerRadius - zigzagR);
      const numTotal = Math.max(1, Math.floor(circumference / (zigzagR * 1.5)));
      let numShow = bottomIcing.isAnimating ? Math.floor(bottomIcing.animationProgress * numTotal) : numTotal;
      for (let i = 0; i < numShow; i++) {
        const ang = (i / numTotal) * Math.PI * 2;
        const zigzagGroup = new THREE.Group();
        const point = new THREE.Mesh(
          new THREE.ConeGeometry(zigzagR * 0.8, zigzagR * 1.5, 4),
          bottomIcingMaterial
        );
        point.rotation.x = -Math.PI / 2; // Point downward for bottom icing
        const base = new THREE.Mesh(
          new THREE.CylinderGeometry(zigzagR * 0.6, zigzagR * 0.6, zigzagR * 0.3, 4),
          bottomIcingMaterial
        );
        base.position.y = zigzagR * 0.9; // Position above downward-pointing zigzag
        zigzagGroup.add(point);
        zigzagGroup.add(base);
        const zigzagRadius = layerRadius - zigzagR * 0.7;
        zigzagGroup.position.set(
          Math.cos(ang) * zigzagRadius,
          bottomY - zigzagR * 0.3,
          Math.sin(ang) * zigzagRadius
        );
        zigzagGroup.rotation.y = -ang;
        bottomIcingGroup.add(zigzagGroup);
      }
    }
    if (bottomIcingGroup.children.length > 0) layerMesh.add(bottomIcingGroup);
  }

  // Shared materials for better performance
  const sharedMaterials = {
    sprinkle: new THREE.MeshStandardMaterial({
      roughness: 0.8,
      metalness: 0.1
    }),
    cherry: new THREE.MeshStandardMaterial({
      color: 0xAA0000,
      roughness: 0.4,
      metalness: 0.2
    }),
    cherryStem: new THREE.MeshStandardMaterial({
      color: 0x006400,
      roughness: 0.6
    }),
    strawberry: new THREE.MeshStandardMaterial({
      color: 0xFF3B3B,
      roughness: 0.7,
      metalness: 0.1
    }),
    strawberryLeaf: new THREE.MeshStandardMaterial({
      color: 0x228B22,
      roughness: 0.8
    }),
    // Add more shared materials as needed
  };

  // Shared geometries for better performance
  const sharedGeometries = {
    sprinkle: new THREE.BoxGeometry(0.03, 0.15, 0.03),
    cherryBody: new THREE.SphereGeometry(0.15, 8, 8), // Reduced segments
    cherryStem: new THREE.CylinderGeometry(0.02, 0.02, 0.2, 6), // Reduced segments
    strawberryBody: new THREE.ConeGeometry(0.12, 0.25, 8), // Reduced segments
    strawberryLeaf: new THREE.CylinderGeometry(0.1, 0.05, 0.05, 8),
  };

  // Helper function to dispose of geometries and materials
  const disposeObject = (object) => {
    if (object.isMesh) {
      if (object.geometry && !Object.values(sharedGeometries).includes(object.geometry)) {
        object.geometry.dispose();
      }
      if (object.material) {
        if (Array.isArray(object.material)) {
          object.material.forEach(material => material.dispose());
        } else {
            object.material.dispose();
        }
      }
    }
    if (object.children) {
      object.children.forEach(child => disposeObject(child));
    }
  };

  const overallToppingGroup = new THREE.Group();
  overallToppingGroup.name = "toppingGroup";
  toppings.forEach(topping => {
    if (topping.type === 'sprinkles') {
      const sprinkleCount = 75; // Reduced from 150 for better performance
      for (let i = 0; i < sprinkleCount; i++) {
        const sprinkle = new THREE.Mesh(sharedGeometries.sprinkle, sharedMaterials.sprinkle.clone());
        sprinkle.material.color.setHSL(Math.random(), 0.8, 0.6);
        const angle = Math.random() * Math.PI * 2;
        const sprinkleRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - 0.1;
        const dist = Math.random() * Math.max(0, sprinkleRadius);
        sprinkle.position.set(Math.cos(angle) * dist, topY + 0.075, Math.sin(angle) * dist);
        sprinkle.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
        overallToppingGroup.add(sprinkle);
      }
    } else if (topping.type === 'cherries') {
      const cherryCount = Math.max(1, Math.floor(layerRadius * 2)); // Reduced multiplier from 3 to 2
      for (let i = 0; i < cherryCount; i++) {
        const cherry = new THREE.Group();
        const body = new THREE.Mesh(sharedGeometries.cherryBody, sharedMaterials.cherry);
        cherry.add(body);
        const stem = new THREE.Mesh(sharedGeometries.cherryStem, sharedMaterials.cherryStem);
        stem.position.y = 0.15 + 0.05;
        stem.rotation.z = Math.PI / 6;
        cherry.add(stem);
        
        let angle, dist;
        const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - 0.15;
        if (cherryCount === 1) {
          angle = 0;
          dist = 0;
        } else {
          // Improved distribution using golden ratio for better spacing
          const goldenRatio = 0.618033988749895;
          angle = (i * goldenRatio * Math.PI * 2) % (Math.PI * 2);
          // Create multiple rings of cherries
          const ringIndex = Math.floor(i / (cherryCount / 3));
          const ringRadius = (availableRadius * 0.75) * (ringIndex + 1) / 3;
          dist = ringRadius;
          // Add slight randomness to position
          dist += (Math.random() - 0.5) * (availableRadius * 0.1);
        }
        cherry.position.set(Math.cos(angle) * dist, topY + 0.15, Math.sin(angle) * dist);
        // Add slight random rotation for more natural look
        cherry.rotation.y = Math.random() * Math.PI * 2;
        overallToppingGroup.add(cherry);
      }
    } else if (topping.type === 'strawberries') {
      // Simplified strawberry creation - no individual seeds for better performance
      const strawberryPosition = layerConfig.strawberryPosition || 'inner';
      const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - 0.15;
      
      // Define positioning based on user selection
      let rings = [];
      const minRadius = 0.2;
      const strawberrySpacing = 0.5; // Increased spacing for fewer strawberries
      
      if (strawberryPosition === 'inner') {
        const innerRadius = minRadius + (availableRadius - minRadius) * 0.3;
        const circumference = 2 * Math.PI * innerRadius;
        const strawberryCount = Math.max(2, Math.floor(circumference / strawberrySpacing));
        rings = [{ radius: innerRadius, count: strawberryCount }];
      } else if (strawberryPosition === 'mid') {
        const midRadius = minRadius + (availableRadius - minRadius) * 0.6;
        const circumference = 2 * Math.PI * midRadius;
        const strawberryCount = Math.max(3, Math.floor(circumference / strawberrySpacing));
        rings = [{ radius: midRadius, count: strawberryCount }];
      } else if (strawberryPosition === 'outer') {
        const outerRadius = availableRadius * 0.9;
        const circumference = 2 * Math.PI * outerRadius;
        const strawberryCount = Math.max(4, Math.floor(circumference / strawberrySpacing));
        rings = [{ radius: outerRadius, count: strawberryCount }];
      } else if (strawberryPosition === 'all') {
        const numberOfRings = 2; // Reduced from 3 rings
        for (let ring = 0; ring < numberOfRings; ring++) {
          const ringRadius = minRadius + (ring / (numberOfRings - 1)) * (availableRadius - minRadius);
          const circumference = 2 * Math.PI * ringRadius;
          const strawberriesInRing = Math.max(2, Math.floor(circumference / strawberrySpacing));
          rings.push({ radius: ringRadius, count: strawberriesInRing });
        }
      }

      // Create strawberries for each ring (simplified version)
      rings.forEach((ring, ringIndex) => {
        for (let i = 0; i < ring.count; i++) {
          const strawberry = new THREE.Group();
          
          // Create strawberry body with size variation
          const sizeVariation = 0.8 + Math.random() * 0.4;
          const body = new THREE.Mesh(sharedGeometries.strawberryBody, sharedMaterials.strawberry);
          body.scale.setScalar(sizeVariation);
          body.rotation.x = Math.PI; // Flip upside down
          strawberry.add(body);
          
          // Add green top/leaves
          const leaves = new THREE.Mesh(sharedGeometries.strawberryLeaf, sharedMaterials.strawberryLeaf);
          leaves.scale.setScalar(sizeVariation);
          leaves.position.y = 0.125 * sizeVariation;
          strawberry.add(leaves);
          
          // Position strawberry
          const baseAngle = (i / ring.count) * Math.PI * 2;
          strawberry.position.set(
            Math.cos(baseAngle) * ring.radius,
            topY + 0.125 * sizeVariation,
            Math.sin(baseAngle) * ring.radius
          );
          
          // Add natural rotation
          strawberry.rotation.y = Math.random() * Math.PI * 2;
          overallToppingGroup.add(strawberry);
        }
      });
    } else if (topping.type === 'blueberries') {
      const blueberryCount = Math.max(2, Math.floor(layerRadius * 5)); // More blueberries as they're smaller
      const blueberryMaterial = new THREE.MeshStandardMaterial({
        color: 0x4169E1,
        roughness: 0.5,
        metalness: 0.2
      });
      const highlightMaterial = new THREE.MeshStandardMaterial({
        color: 0xE6E6FA,
        roughness: 0.3,
        metalness: 0.4
      });

      for (let i = 0; i < blueberryCount; i++) {
        const blueberry = new THREE.Group();
        
        // Create blueberry body (small sphere)
        const bodyRadius = 0.07 + Math.random() * 0.02; // Slight size variation
        const bodyGeo = new THREE.SphereGeometry(bodyRadius, 12, 12);
        const body = new THREE.Mesh(bodyGeo, blueberryMaterial);
        blueberry.add(body);
        
        // Add highlight spot (small white dot)
        const highlightGeo = new THREE.SphereGeometry(bodyRadius * 0.2, 6, 6);
        const highlight = new THREE.Mesh(highlightGeo, highlightMaterial);
        highlight.position.set(bodyRadius * 0.5, bodyRadius * 0.5, 0);
        blueberry.add(highlight);
        
        // Position the blueberry on the cake
        const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - bodyRadius;
        
        // Distribute blueberries in clusters and across the cake top
        let angle, dist;
        
        if (i % 3 === 0) {
          // Create clusters
          const clusterIndex = Math.floor(i / 3);
          const clusterAngle = (clusterIndex * Math.PI * 0.5) % (Math.PI * 2);
          angle = clusterAngle + (Math.random() - 0.5) * 0.5; // Small angle variation within cluster
          dist = availableRadius * (0.4 + Math.random() * 0.5);
        } else {
          // Random placement
          angle = Math.random() * Math.PI * 2;
          dist = Math.random() * availableRadius;
        }
        
        blueberry.position.set(
          Math.cos(angle) * dist, 
          topY + bodyRadius, 
          Math.sin(angle) * dist
        );
        
        // Random rotation
        blueberry.rotation.x = Math.random() * Math.PI;
        blueberry.rotation.y = Math.random() * Math.PI;
        blueberry.rotation.z = Math.random() * Math.PI;
        
        overallToppingGroup.add(blueberry);
      }
    } else if (topping.type === 'candle') {
      const candleCount = 1; // Changed to always show only 1 candle
      const candleMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFFF,
        roughness: 0.3,
        metalness: 0.1
      });
      const flameMaterial = new THREE.MeshStandardMaterial({
        color: 0xFF6600,
        roughness: 0.1,
        metalness: 0.0,
        emissive: 0xFF3300,
        emissiveIntensity: 0.2
      });
      const wickMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.8
      });

      for (let i = 0; i < candleCount; i++) {
        const candle = new THREE.Group();
        
        // Create candle body (cylinder)
        const bodyRadius = 0.04;
        const bodyHeight = 0.8;
        const bodyGeo = new THREE.CylinderGeometry(bodyRadius, bodyRadius, bodyHeight, 16);
        const body = new THREE.Mesh(bodyGeo, candleMaterial);
        candle.add(body);
        
        // Add wick (small cylinder)
        const wickGeo = new THREE.CylinderGeometry(0.01, 0.01, 0.1, 8);
        const wick = new THREE.Mesh(wickGeo, wickMaterial);
        wick.position.y = bodyHeight / 2 + 0.05;
        candle.add(wick);
        
        // Add flame (small sphere)
        const flameGeo = new THREE.SphereGeometry(0.03, 8, 8);
        const flame = new THREE.Mesh(flameGeo, flameMaterial);
        flame.position.y = bodyHeight / 2 + 0.12;
        candle.add(flame);
        
        // Position the single candle at the center of the cake
        candle.position.set(
          0, // Center horizontally
          topY + bodyHeight / 2, 
          0 // Center depth-wise
        );
        
        overallToppingGroup.add(candle);
      }
    } else if (topping.type === 'crush_oreo') {
      const oreoCount = Math.max(20, Math.floor(layerRadius * 15)); // Many small oreo pieces
      const oreoMaterial = new THREE.MeshStandardMaterial({
        color: 0x2F1B1B,
        roughness: 0.8,
        metalness: 0.1
      });
      const creamMaterial = new THREE.MeshStandardMaterial({
        color: 0xFFFFF0,
        roughness: 0.5,
        metalness: 0.1
      });

      for (let i = 0; i < oreoCount; i++) {
        const oreoGroup = new THREE.Group();
        
        // Create irregular oreo crumb shapes - increased size
        const crumbSize = 0.04 + Math.random() * 0.06; // Increased from 0.02-0.05 to 0.04-0.10
        const crumbGeo = new THREE.BoxGeometry(
          crumbSize, 
          crumbSize * 0.3, 
          crumbSize * 0.8
        );
        const crumb = new THREE.Mesh(crumbGeo, oreoMaterial);
        oreoGroup.add(crumb);
        
        // Sometimes add cream pieces
        if (Math.random() < 0.3) {
          const creamGeo = new THREE.SphereGeometry(crumbSize * 0.5, 6, 6);
          const cream = new THREE.Mesh(creamGeo, creamMaterial);
          cream.position.y = crumbSize * 0.2;
          oreoGroup.add(cream);
        }
        
        // Position the oreo crumb on the cake
        const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0);
        
        // Random distribution across cake top
        const angle = Math.random() * Math.PI * 2;
        const dist = Math.random() * availableRadius;
        
        oreoGroup.position.set(
          Math.cos(angle) * dist, 
          topY + crumbSize, 
          Math.sin(angle) * dist
        );
        
        // Random rotation for natural look
        oreoGroup.rotation.x = Math.random() * Math.PI;
        oreoGroup.rotation.y = Math.random() * Math.PI;
        oreoGroup.rotation.z = Math.random() * Math.PI;
        
        overallToppingGroup.add(oreoGroup);
      }
    } else if (topping.type === 'christmas_balls') {
      const ballCount = Math.max(3, Math.floor(layerRadius * 2)); // Fewer balls as they're decorative
      const ballColors = [0xFF0000, 0x00FF00, 0xFFD700, 0x0000FF, 0xFF69B4]; // Red, Green, Gold, Blue, Pink

      for (let i = 0; i < ballCount; i++) {
        const ball = new THREE.Group();
        
        // Create main ball - increased size
        const ballRadius = 0.15 + Math.random() * 0.08; // Increased from 0.08-0.12 to 0.15-0.23
        const ballGeo = new THREE.SphereGeometry(ballRadius, 16, 16);
        const ballColor = ballColors[Math.floor(Math.random() * ballColors.length)];
        const ballMaterial = new THREE.MeshStandardMaterial({
          color: ballColor,
          roughness: 0.1,
          metalness: 0.8
        });
        const ballMesh = new THREE.Mesh(ballGeo, ballMaterial);
        ball.add(ballMesh);
        
        // Add cap (small cylinder at top)
        const capGeo = new THREE.CylinderGeometry(ballRadius * 0.3, ballRadius * 0.3, ballRadius * 0.3, 12);
        const capMaterial = new THREE.MeshStandardMaterial({
          color: 0xFFD700,
          roughness: 0.2,
          metalness: 0.9
        });
        const cap = new THREE.Mesh(capGeo, capMaterial);
        cap.position.y = ballRadius + ballRadius * 0.15;
        ball.add(cap);
        
        // Position the ball on the cake
        const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - ballRadius;
        
        // Distribute balls around the cake
        const angle = (i / ballCount) * Math.PI * 2 + Math.random() * 0.5;
        const dist = availableRadius * (0.3 + Math.random() * 0.5);
        
        ball.position.set(
          Math.cos(angle) * dist, 
          topY + ballRadius, 
          Math.sin(angle) * dist
        );
        
        overallToppingGroup.add(ball);
      }
    } else if (topping.type === 'flowers') {
      // Get the selected flower position and rose color from layer config
      const flowerPosition = layerConfig.flowerPosition || 'inner';
      const selectedRoseColor = layerConfig.roseColor || 'red';
      const availableRadius = layerRadius - (edgeIcing.enabled ? edgeIcing.thickness : 0) - 0.25; // Increased from 0.15 to 0.25
      
      // Define rose colors
      const roseColors = {
        red: 0xDC143C,
        pink: 0xFF69B4,
        white: 0xFFFFF0,
        yellow: 0xFFD700,
        purple: 0x9370DB,
        orange: 0xFF8C00
      };
      
      const roseColor = roseColors[selectedRoseColor] || roseColors.red;
      
      // Define positioning based on user selection
      let rings = [];
      const minRadius = 0.25; // Increased from 0.2 to 0.25
      const flowerSpacing = 0.75; // Increased from 0.5 to 0.75 for larger roses
      
      if (flowerPosition === 'inner') {
        // Single inner ring close to center with circumference-based count
        const innerRadius = minRadius + (availableRadius - minRadius) * 0.3;
        const circumference = 2 * Math.PI * innerRadius;
        const flowerCount = Math.max(4, Math.floor(circumference / flowerSpacing));
        rings = [{ radius: innerRadius, count: flowerCount }];
      } else if (flowerPosition === 'mid') {
        // Single middle ring with circumference-based count
        const midRadius = minRadius + (availableRadius - minRadius) * 0.6;
        const circumference = 2 * Math.PI * midRadius;
        const flowerCount = Math.max(5, Math.floor(circumference / flowerSpacing));
        rings = [{ radius: midRadius, count: flowerCount }];
      } else if (flowerPosition === 'outer') {
        // Single outer ring near edge with circumference-based count
        const outerRadius = availableRadius * 0.9;
        const circumference = 2 * Math.PI * outerRadius;
        const flowerCount = Math.max(6, Math.floor(circumference / flowerSpacing));
        rings = [{ radius: outerRadius, count: flowerCount }];
      } else if (flowerPosition === 'all') {
        // Multiple concentric circles for full coverage
        const numberOfRings = 3;
        for (let ring = 0; ring < numberOfRings; ring++) {
          const ringRadius = minRadius + (ring / (numberOfRings - 1)) * (availableRadius - minRadius);
          const circumference = 2 * Math.PI * ringRadius;
          const flowersInRing = Math.max(3, Math.floor(circumference / flowerSpacing));
          rings.push({ radius: ringRadius, count: flowersInRing });
        }
      }
      
      // Generate flowers for each ring
      rings.forEach(ring => {
        for (let i = 0; i < ring.count; i++) {
          const rose = new THREE.Group();
          
          // Create 3D Rose with layered petals
          const roseMaterial = new THREE.MeshStandardMaterial({
            color: roseColor,
            roughness: 0.3,
            metalness: 0.1
          });
          
          // Create rose center (small sphere)
          const centerGeo = new THREE.SphereGeometry(0.05, 8, 8); // Increased from 0.03 to 0.05
          const center = new THREE.Mesh(centerGeo, roseMaterial);
          rose.add(center);
          
          // Create multiple layers of petals for 3D rose effect
          const petalLayers = 4; // Number of petal layers
          
          for (let layer = 0; layer < petalLayers; layer++) {
            const layerRadius = 0.06 + (layer * 0.035); // Increased from 0.04+0.025 to 0.06+0.035
            const petalsInLayer = 5 + layer; // More petals in outer layers
            const layerHeight = layer * 0.03; // Increased from 0.02 to 0.03
            
            for (let p = 0; p < petalsInLayer; p++) {
              const petalAngle = (p / petalsInLayer) * Math.PI * 2 + (layer * 0.3); // Offset each layer
              
              // Create petal using ellipsoid geometry for more realistic shape
              const petalGeo = new THREE.SphereGeometry(0.035 + layer * 0.015, 6, 4); // Increased from 0.025+0.01 to 0.035+0.015
              const petal = new THREE.Mesh(petalGeo, roseMaterial);
              
              // Position petal around the center
              const petalX = Math.cos(petalAngle) * layerRadius;
              const petalZ = Math.sin(petalAngle) * layerRadius;
              const petalY = layerHeight;
              
              petal.position.set(petalX, petalY, petalZ);
              
              // Scale and rotate petal for rose-like appearance
              petal.scale.set(1.5 + layer * 0.4, 0.4, 1.0 + layer * 0.3); // Increased from 1.2+0.3, 0.4, 0.8+0.2
              
              // Tilt petals outward and upward for realistic rose shape
              petal.rotation.x = -Math.PI / 6 + (layer * Math.PI / 12);
              petal.rotation.y = petalAngle;
              petal.rotation.z = (Math.random() - 0.5) * 0.3; // Small random rotation
              
              rose.add(petal);
            }
          }
          
          // Add some outer guard petals for more realistic rose
          const guardPetals = 6;
          for (let g = 0; g < guardPetals; g++) {
            const guardAngle = (g / guardPetals) * Math.PI * 2;
            const guardGeo = new THREE.SphereGeometry(0.06, 6, 4);
            const guardPetal = new THREE.Mesh(guardGeo, roseMaterial);
            
            const guardRadius = 0.18;
            guardPetal.position.set(
              Math.cos(guardAngle) * guardRadius,
              -0.02,
              Math.sin(guardAngle) * guardRadius
            );
            
            guardPetal.scale.set(1.8, 0.3, 1.2);
            guardPetal.rotation.x = -Math.PI / 4;
            guardPetal.rotation.y = guardAngle;
            guardPetal.rotation.z = (Math.random() - 0.5) * 0.4;
            
            rose.add(guardPetal);
          }
          
          // Add green leaves to the rose
          const leafMaterial = new THREE.MeshStandardMaterial({
            color: 0x2E8B57, // Sea green color for leaves
            roughness: 0.7,
            metalness: 0.1
          });
          
          // Add 2-3 leaves around the base of the rose
          const leafCount = 2 + Math.floor(Math.random() * 2); // 2-3 leaves
          for (let l = 0; l < leafCount; l++) {
            const leafAngle = (l / leafCount) * Math.PI * 2;
            
            // Create leaf using modified sphere geometry
            const leafGeo = new THREE.SphereGeometry(0.08, 6, 4);
            const leaf = new THREE.Mesh(leafGeo, leafMaterial);
            
            // Position leaf at the base of the rose, slightly offset
            const leafRadius = 0.2;
            leaf.position.set(
              Math.cos(leafAngle) * leafRadius,
              -0.1 - Math.random() * 0.05, // Below the rose
              Math.sin(leafAngle) * leafRadius
            );
            
            // Scale to create an elongated leaf shape
            leaf.scale.set(1.5, 0.2, 0.8);
            
            // Rotate to position naturally
            leaf.rotation.x = Math.PI / 3 + (Math.random() - 0.5) * 0.2; // Angle upward
            leaf.rotation.y = leafAngle + (Math.random() - 0.5) * 0.3; // Face outward
            leaf.rotation.z = (Math.random() - 0.5) * 0.4; // Random tilt
            
            rose.add(leaf);
          }
          
          // Position the rose in the current ring
          const angle = (i / ring.count) * Math.PI * 2;
          
          rose.position.set(
            Math.cos(angle) * ring.radius, 
            topY + 0.12, // Increased from 0.08 to 0.12
            Math.sin(angle) * ring.radius
          );
          
          // Random rotation for natural look
          rose.rotation.y = Math.random() * Math.PI * 2;
          
          overallToppingGroup.add(rose);
        }
      });
      
      // Add a center rose for inner and all positions if there's space
      if ((flowerPosition === 'inner' || flowerPosition === 'all') && minRadius > 0.15) {
        const centerRose = new THREE.Group();
        
        // Create center 3D Rose
        const roseMaterial = new THREE.MeshStandardMaterial({
            color: roseColor,
          roughness: 0.3,
          metalness: 0.1
        });
        
        // Create rose center
        const centerGeo = new THREE.SphereGeometry(0.05, 8, 8); // Increased from 0.03 to 0.05
        const center = new THREE.Mesh(centerGeo, roseMaterial);
        centerRose.add(center);
        
        // Create multiple layers of petals
        const petalLayers = 4;
        
        for (let layer = 0; layer < petalLayers; layer++) {
          const layerRadius = 0.06 + (layer * 0.035);
          const petalsInLayer = 5 + layer;
          const layerHeight = layer * 0.03;
          
          for (let p = 0; p < petalsInLayer; p++) {
            const petalAngle = (p / petalsInLayer) * Math.PI * 2 + (layer * 0.3);
            
            const petalGeo = new THREE.SphereGeometry(0.035 + layer * 0.015, 6, 4);
            const petal = new THREE.Mesh(petalGeo, roseMaterial);
            
            const petalX = Math.cos(petalAngle) * layerRadius;
            const petalZ = Math.sin(petalAngle) * layerRadius;
            const petalY = layerHeight;
            
            petal.position.set(petalX, petalY, petalZ);
            petal.scale.set(1.5 + layer * 0.4, 0.4, 1.0 + layer * 0.3);
            petal.rotation.x = -Math.PI / 6 + (layer * Math.PI / 12);
            petal.rotation.y = petalAngle;
            petal.rotation.z = (Math.random() - 0.5) * 0.3;
            
            centerRose.add(petal);
          }
        }
        
        // Add guard petals
        const guardPetals = 6;
        for (let g = 0; g < guardPetals; g++) {
          const guardAngle = (g / guardPetals) * Math.PI * 2;
          const guardGeo = new THREE.SphereGeometry(0.06, 6, 4);
          const guardPetal = new THREE.Mesh(guardGeo, roseMaterial);
          
          const guardRadius = 0.18;
          guardPetal.position.set(
            Math.cos(guardAngle) * guardRadius,
            -0.02,
            Math.sin(guardAngle) * guardRadius
          );
          
          guardPetal.scale.set(1.8, 0.3, 1.2);
          guardPetal.rotation.x = -Math.PI / 4;
          guardPetal.rotation.y = guardAngle;
          guardPetal.rotation.z = (Math.random() - 0.5) * 0.4;
          
          centerRose.add(guardPetal);
        }
        
        // Add green leaves to the center rose
        const leafMaterial = new THREE.MeshStandardMaterial({
          color: 0x2E8B57, // Sea green color for leaves
          roughness: 0.7,
          metalness: 0.1
        });
        
        // Add 2-3 leaves around the base of the rose
        const leafCount = 2 + Math.floor(Math.random() * 2); // 2-3 leaves
        for (let l = 0; l < leafCount; l++) {
          const leafAngle = (l / leafCount) * Math.PI * 2;
          
          // Create leaf using modified sphere geometry
          const leafGeo = new THREE.SphereGeometry(0.08, 6, 4);
          const leaf = new THREE.Mesh(leafGeo, leafMaterial);
          
          // Position leaf at the base of the rose, slightly offset
          const leafRadius = 0.2;
          leaf.position.set(
            Math.cos(leafAngle) * leafRadius,
            -0.1 - Math.random() * 0.05, // Below the rose
            Math.sin(leafAngle) * leafRadius
          );
          
          // Scale to create an elongated leaf shape
          leaf.scale.set(1.5, 0.2, 0.8);
          
          // Rotate to position naturally
          leaf.rotation.x = Math.PI / 3 + (Math.random() - 0.5) * 0.2; // Angle upward
          leaf.rotation.y = leafAngle + (Math.random() - 0.5) * 0.3; // Face outward
          leaf.rotation.z = (Math.random() - 0.5) * 0.4; // Random tilt
          
          centerRose.add(leaf);
        }
        
        // Position at center
        centerRose.position.set(0, topY + 0.12, 0); // Increased from 0.08 to 0.12
        centerRose.rotation.y = Math.random() * Math.PI * 2;
        
        overallToppingGroup.add(centerRose);
      }
    }
  });
  if (overallToppingGroup.children.length > 0) layerMesh.add(overallToppingGroup);
};

// Greeting config and group
const greetingConfig = reactive({
  enabled: false,
  text: 'Happy B-Day!',
  color: '#333333',
  size: 0.25,
  depth: 0.05,
  layout: 'horizontal-top'
});

function onGreetingChange() {
  renderCake();
}

// Computed property to get the currently selected layer configuration
const selectedLayerConfig = computed(() => {
  if (!selectedLayerId.value) return null;
  const layer = cakeLayers.value.find(l => l.id === selectedLayerId.value);
  return layer;
});

// Function to update topping state
const updateToppingState = (toppingType, enabled) => {
  if (!selectedLayerId.value) return;
  
  const layer = cakeLayers.value.find(l => l.id === selectedLayerId.value);
  if (!layer) return;
  
  saveToHistory(); // Save state before making changes
  
  const existingToppingIndex = layer.toppings.findIndex(t => t.type === toppingType);
  
  if (enabled) {
    if (existingToppingIndex === -1) {
      layer.toppings.push({ type: toppingType });
    }
  } else {
    if (existingToppingIndex !== -1) {
      layer.toppings.splice(existingToppingIndex, 1);
    }
  }
  
  // Use debounced render for better performance
  debouncedRender();
};

const handleImageUpload = (event) => {
  const file = event.target.files[0];
  if (file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      updateLayerProperty(selectedLayerId.value, 'topper.image', e.target.result);
    };
    reader.readAsDataURL(file);
  }
};

const addGreetingTextToCake = (currentHeightOffset, topLayerRadius, topLayerHeight) => {
  // Safety check to ensure cakeGroup is initialized
  if (!cakeGroup) {
    console.warn('cakeGroup not initialized yet, skipping greeting text');
    return;
  }
  
  // Remove existing greeting text if any
  const existingGreeting = cakeGroup.getObjectByName("greetingGroup");
  if (existingGreeting) {
    if (typeof disposeObject === 'function') {
    disposeObject(existingGreeting);
    }
    cakeGroup.remove(existingGreeting);
  }

  if (!greetingConfig.enabled || !greetingConfig.text || !loadedFont) {
    return;
  }

  const greetingGroup = new THREE.Group();
  greetingGroup.name = "greetingGroup";

  const textGeometry = new TextGeometry(greetingConfig.text, {
    font: loadedFont,
    size: greetingConfig.size,
    height: greetingConfig.depth,
    curveSegments: 12,
    bevelEnabled: false
  });

  textGeometry.computeBoundingBox();
  const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
  const textHeight = textGeometry.boundingBox.max.y - textGeometry.boundingBox.min.y;

  const textMaterial = new THREE.MeshStandardMaterial({
    color: greetingConfig.color,
    roughness: 0.7,
    metalness: 0.1
  });

  const textMesh = new THREE.Mesh(textGeometry, textMaterial);

  // Position the text based on layout
  switch (greetingConfig.layout) {
    case 'horizontal-top':
      textMesh.rotation.x = -Math.PI / 2;
      textMesh.position.set(
        -textWidth / 2,
        currentHeightOffset + 0.01, // Just above the cake's top
        0
      );
      break;
    case 'circular-top':
      textMesh.position.set(0, currentHeightOffset + topLayerHeight / 2 + 0.1, 0);
      textMesh.rotation.x = -Math.PI / 2;
      // Create a circular path for the text
      const radius = topLayerRadius * 0.8;
      const textPath = new THREE.CurvePath();
      const circle = new THREE.EllipseCurve(0, 0, radius, radius, 0, Math.PI * 2, false, 0);
      textPath.add(circle);
      // Apply the path to the text
      textMesh.geometry = new THREE.TextGeometry(greetingConfig.text, {
        font: loadedFont,
        size: greetingConfig.size,
        height: greetingConfig.depth,
        curveSegments: 12,
        bevelEnabled: false,
        path: textPath
      });
      break;
    case 'vertical-side':
      textMesh.position.set(topLayerRadius + 0.1, currentHeightOffset - topLayerHeight / 2, 0);
      textMesh.rotation.y = Math.PI / 2;
      break;
  }

  greetingGroup.add(textMesh);
  cakeGroup.add(greetingGroup);
};

const addIcingControlsUI = (layerConfig, container) => {
  const icingControlsDiv = document.createElement('div');
  icingControlsDiv.className = 'control-group';
  
  // Create unique IDs for the icing tab controls to avoid conflicts with Layer Editor
  const edgeIcingSubControlsId = `icing_tab_edge_controls_${layerConfig.id}`;
  const bottomIcingSubControlsId = `icing_tab_bottom_controls_${layerConfig.id}`;
  
  icingControlsDiv.innerHTML = `
    <p class="text-xl font-bold text-center p-2 my-2">Layer ${cakeLayers.value.findIndex(l => l.id === layerConfig.id) + 1} Icing</p>
    
    <div class="icing-section p-3 border border-b-2 border-gray-300 m-2">
      <div class="flex items-center ">
        <div class="relative flex items-start">
          <div class="flex items-center h-5">
            <input type="checkbox" id="icing_tab_edge_enabled_${layerConfig.id}" ${layerConfig.edgeIcing.enabled ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 transition duration-150 ease-in-out cursor-pointer">
          </div>
          <div class="ml-3 text-sm">
            <label for="icing_tab_edge_enabled_${layerConfig.id}" class="font-medium text-gray-700 cursor-pointer select-none">Enable Edge Icing</label>
            <p class="text-gray-500 text-xs mt-1">Add decorative icing around the edge of your cake</p>
          </div>
        </div>
      </div>
      <div id="${edgeIcingSubControlsId}" class="sub-controls mt-2 ${layerConfig.edgeIcing.enabled ? '' : 'hidden'}">
        <div class="mt-1">
          <label for="icing_tab_edge_style_${layerConfig.id}" class="block text-sm font-medium text-gray-700 mb-1">Edge Style:</label>
          <div class="relative">
            <select id="icing_tab_edge_style_${layerConfig.id}" class="block w-full rounded-md border border-gray-300 shadow py-2 pl-3 pr-10 text-base focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm appearance-none bg-white">
              <option value="smooth" ${layerConfig.edgeIcing.style === 'smooth' ? 'selected' : ''}>Smooth Ring</option>
              <option value="curl" ${layerConfig.edgeIcing.style === 'curl' ? 'selected' : ''}>Curl Pattern</option>
              <option value="shell" ${layerConfig.edgeIcing.style === 'shell' ? 'selected' : ''}>Shell Pattern</option>
              <option value="rosette" ${layerConfig.edgeIcing.style === 'rosette' ? 'selected' : ''}>Rosette Pattern</option>
              <option value="ruffle" ${layerConfig.edgeIcing.style === 'ruffle' ? 'selected' : ''}>Ruffle Pattern</option>
              <option value="zigzag" ${layerConfig.edgeIcing.style === 'zigzag' ? 'selected' : ''}>Zigzag Pattern</option>
            </select>
            <div class="pointer-events-none absolute inset-y-0 right-0 flex items-center px-2 text-gray-700">
              <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor" aria-hidden="true">
                <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd" />
              </svg>
            </div>
          </div>
        </div>
        <div class="mt-2">
          <label for="icing_tab_edge_color_${layerConfig.id}" class="block text-sm font-medium text-gray-700 mb-1">Edge Color:</label>
          <input type="color" id="icing_tab_edge_color_${layerConfig.id}" value="${layerConfig.edgeIcing.color}" class="h-9 w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
        </div>
        <div class="mt-2">
          <label for="icing_tab_edge_thickness_${layerConfig.id}" class="block text-sm font-medium text-gray-700 mb-1">Edge Detail/Thickness (${layerConfig.edgeIcing.thickness.toFixed(2)}):</label>
          <input type="range" id="icing_tab_edge_thickness_${layerConfig.id}" min="0.02" max="0.3" step="0.01" value="${layerConfig.edgeIcing.thickness}" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
        </div>
      </div>
    </div>



    <div class="icing-section p-3 border border-b-2 border-gray-300 m-2">
      <div class="flex items-center">
        <div class="relative flex items-start">
          <div class="flex items-center h-5">
            <input type="checkbox" id="icing_tab_bottom_enabled_${layerConfig.id}" ${layerConfig.bottomIcing.enabled ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 transition duration-150 ease-in-out cursor-pointer">
          </div>
          <div class="ml-3 text-sm">
            <label for="icing_tab_bottom_enabled_${layerConfig.id}" class="font-medium text-gray-700 cursor-pointer select-none">Enable Bottom Icing</label>
            <p class="text-gray-500 text-xs mt-1">Add decorative icing to the bottom edge of your cake</p>
          </div>
        </div>
      </div>
      <div id="${bottomIcingSubControlsId}" class="sub-controls mt-2 ${layerConfig.bottomIcing.enabled ? '' : 'hidden'}">
        <div class="mt-1">
          <label for="icing_tab_bottom_style_${layerConfig.id}">Bottom Style:</label>
          <select id="icing_tab_bottom_style_${layerConfig.id}" class="block w-full rounded-md border border-gray-300 shadow py-2 pl-3 pr-10 text-base focus:border-indigo-500 focus:outline-none focus:ring-indigo-500 sm:text-sm appearance-none bg-white">
            <option value="smooth" ${layerConfig.bottomIcing.style === 'smooth' ? 'selected' : ''}>Smooth Ring</option>
            <option value="curl" ${layerConfig.bottomIcing.style === 'curl' ? 'selected' : ''}>Curl Pattern</option>
            <option value="shell" ${layerConfig.bottomIcing.style === 'shell' ? 'selected' : ''}>Shell Pattern</option>
            <option value="rosette" ${layerConfig.bottomIcing.style === 'rosette' ? 'selected' : ''}>Rosette Pattern</option>
            <option value="ruffle" ${layerConfig.bottomIcing.style === 'ruffle' ? 'selected' : ''}>Ruffle Pattern</option>
            <option value="zigzag" ${layerConfig.bottomIcing.style === 'zigzag' ? 'selected' : ''}>Zigzag Pattern</option>
          </select>
        </div>
        <div class="mt-2">
          <label for="icing_tab_bottom_color_${layerConfig.id}">Bottom Color:</label>
          <input type="color" id="icing_tab_bottom_color_${layerConfig.id}" value="${layerConfig.bottomIcing.color}" class="h-9 w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500">
        </div>
        <div class="mt-2">
          <label for="icing_tab_bottom_thickness_${layerConfig.id}" class="block text-sm font-medium text-gray-700 mb-1">Bottom Detail/Thickness (${layerConfig.bottomIcing.thickness.toFixed(2)}):</label>
          <input type="range" id="icing_tab_bottom_thickness_${layerConfig.id}" min="0.02" max="0.3" step="0.01" value="${layerConfig.bottomIcing.thickness}" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-indigo-600">
        </div>
      </div>
    </div>
  `;
  
  container.appendChild(icingControlsDiv);
  
  // Add event listeners for icing controls with the correct IDs
  const edgeIcingEnabledCheckbox = document.getElementById(`icing_tab_edge_enabled_${layerConfig.id}`);
  const edgeIcingSubControlsDiv = document.getElementById(edgeIcingSubControlsId);
  
  edgeIcingEnabledCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'edgeIcing.enabled', e.target.checked);
    edgeIcingSubControlsDiv.classList.toggle('hidden', !e.target.checked);
  });
  
  document.getElementById(`icing_tab_edge_style_${layerConfig.id}`).addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'edgeIcing.style', e.target.value);
  });
  
  document.getElementById(`icing_tab_edge_color_${layerConfig.id}`).addEventListener('input', (e) => {
    updateLayerProperty(layerConfig.id, 'edgeIcing.color', e.target.value);
  });
  
  document.getElementById(`icing_tab_edge_thickness_${layerConfig.id}`).addEventListener('input', throttledInputHandler((e) => {
    updateLayerProperty(layerConfig.id, 'edgeIcing.thickness', parseFloat(e.target.value));
  }, 150));
  
  const bottomIcingEnabledCheckbox = document.getElementById(`icing_tab_bottom_enabled_${layerConfig.id}`);
  const bottomIcingSubControlsDiv = document.getElementById(bottomIcingSubControlsId);
  
  bottomIcingEnabledCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'bottomIcing.enabled', e.target.checked);
    bottomIcingSubControlsDiv.classList.toggle('hidden', !e.target.checked);
  });
  
  document.getElementById(`icing_tab_bottom_style_${layerConfig.id}`).addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'bottomIcing.style', e.target.value);
  });
  
  document.getElementById(`icing_tab_bottom_color_${layerConfig.id}`).addEventListener('input', (e) => {
    updateLayerProperty(layerConfig.id, 'bottomIcing.color', e.target.value);
  });
  
  document.getElementById(`icing_tab_bottom_thickness_${layerConfig.id}`).addEventListener('input', throttledInputHandler((e) => {
    updateLayerProperty(layerConfig.id, 'bottomIcing.thickness', parseFloat(e.target.value));
  }, 150));
};

const addToppingsControlsUI = (layerConfig, container) => {
  const toppingsControlsDiv = document.createElement('div');
  toppingsControlsDiv.className = 'control-group';
  
  // Get current toppings state
  const hasSprinkles = layerConfig.toppings.some(t => t.type === 'sprinkles');
  const hasCherries = layerConfig.toppings.some(t => t.type === 'cherries');
  const hasStrawberries = layerConfig.toppings.some(t => t.type === 'strawberries');
  const hasBlueberries = layerConfig.toppings.some(t => t.type === 'blueberries');
  const hasCandle = layerConfig.toppings.some(t => t.type === 'candle');
  const hasCrushOreo = layerConfig.toppings.some(t => t.type === 'crush_oreo');
  const hasChristmasBalls = layerConfig.toppings.some(t => t.type === 'christmas_balls');
  const hasFlowers = layerConfig.toppings.some(t => t.type === 'flowers');
  
  toppingsControlsDiv.innerHTML = `
    <p class="text-xl font-bold text-center p-2 my-2">Layer ${currentLayerNumber} Toppings</p>
    
    <div class="toppings-section p-3 border border-b-2 border-gray-300 m-2">
      <p class="text-sm font-medium text-gray-700 mb-3">Add toppings to your cake layer:</p>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_sprinkles_${layerConfig.id}" ${hasSprinkles ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_sprinkles_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Sprinkles</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasSprinkles ? '' : 'hidden'}" id="sprinkles_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Colorful sprinkles randomly distributed across the top of the cake</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_cherries_${layerConfig.id}" ${hasCherries ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_cherries_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Cherries</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasCherries ? '' : 'hidden'}" id="cherries_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Red cherries with green stems placed on top of your cake</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_strawberries_${layerConfig.id}" ${hasStrawberries ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_strawberries_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Strawberries</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasStrawberries ? '' : 'hidden'}" id="strawberries_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs mb-3">Fresh strawberries piled naturally on your cake</p>
          
          <!-- Strawberry Position Options -->
          <div class="space-y-2">
            <label class="text-sm font-medium text-gray-700">Strawberry Position:</label>
            <div class="space-y-1">
              <label class="flex items-center">
                <input type="radio" name="strawberry_position_${layerConfig.id}" value="inner" ${(!layerConfig.strawberryPosition || layerConfig.strawberryPosition === 'inner') ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Inner (close to center)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="strawberry_position_${layerConfig.id}" value="mid" ${layerConfig.strawberryPosition === 'mid' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Mid (middle area)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="strawberry_position_${layerConfig.id}" value="outer" ${layerConfig.strawberryPosition === 'outer' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Outer (near edge)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="strawberry_position_${layerConfig.id}" value="all" ${layerConfig.strawberryPosition === 'all' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">All (full coverage)</span>
              </label>
            </div>
          </div>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_blueberries_${layerConfig.id}" ${hasBlueberries ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_blueberries_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Blueberries</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasBlueberries ? '' : 'hidden'}" id="blueberries_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Fresh blueberries scattered across the top of your cake</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_candle_${layerConfig.id}" ${hasCandle ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_candle_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Candles</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasCandle ? '' : 'hidden'}" id="candle_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Beautiful birthday candles with flames evenly distributed around your cake</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_crush_oreo_${layerConfig.id}" ${hasCrushOreo ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_crush_oreo_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Crush Oreo</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasCrushOreo ? '' : 'hidden'}" id="crush_oreo_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Crushed Oreo cookies and cream pieces sprinkled across your cake</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_christmas_balls_${layerConfig.id}" ${hasChristmasBalls ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_christmas_balls_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Christmas Balls</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasChristmasBalls ? '' : 'hidden'}" id="christmas_balls_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs">Colorful Christmas ornament balls with golden caps for festive decoration</p>
        </div>
      </div>
      
      <div class="mb-3">
        <div class="flex items-center">
          <div class="flex items-center h-5">
            <input type="checkbox" id="toppings_tab_flowers_${layerConfig.id}" ${hasFlowers ? 'checked' : ''} class="h-5 w-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500 focus:ring-offset-0 cursor-pointer">
          </div>
          <label for="toppings_tab_flowers_${layerConfig.id}" class="ml-3 text-sm font-medium text-gray-700 cursor-pointer select-none">Flowers</label>
        </div>
        <div class="sub-controls pl-8 mt-2 ${hasFlowers ? '' : 'hidden'}" id="flowers_controls_${layerConfig.id}">
          <p class="text-gray-500 text-xs mb-3">Beautiful edible flowers with colorful petals arranged on your cake</p>
          
          <!-- Flower Position Options -->
          <div class="space-y-2">
            <label class="text-sm font-medium text-gray-700">Flower Position:</label>
            <div class="space-y-1">
              <label class="flex items-center">
                <input type="radio" name="flower_position_${layerConfig.id}" value="inner" ${(!layerConfig.flowerPosition || layerConfig.flowerPosition === 'inner') ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Inner (close to center)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="flower_position_${layerConfig.id}" value="mid" ${layerConfig.flowerPosition === 'mid' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Mid (middle area)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="flower_position_${layerConfig.id}" value="outer" ${layerConfig.flowerPosition === 'outer' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">Outer (near edge)</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="flower_position_${layerConfig.id}" value="all" ${layerConfig.flowerPosition === 'all' ? 'checked' : ''} class="mr-2 text-indigo-600">
                <span class="text-sm text-gray-600">All (full coverage)</span>
              </label>
            </div>
          </div>
          
          <!-- Rose Color Options -->
          <div class="space-y-2 mt-4">
            <label class="text-sm font-medium text-gray-700">Rose Color:</label>
            <div class="grid grid-cols-3 gap-2">
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="red" ${(!layerConfig.roseColor || layerConfig.roseColor === 'red') ? 'checked' : ''} class="mr-2 text-red-600">
                <span class="text-sm text-gray-600">Red</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="pink" ${layerConfig.roseColor === 'pink' ? 'checked' : ''} class="mr-2 text-pink-600">
                <span class="text-sm text-gray-600">Pink</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="white" ${layerConfig.roseColor === 'white' ? 'checked' : ''} class="mr-2 text-gray-600">
                <span class="text-sm text-gray-600">White</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="yellow" ${layerConfig.roseColor === 'yellow' ? 'checked' : ''} class="mr-2 text-yellow-600">
                <span class="text-sm text-gray-600">Yellow</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="purple" ${layerConfig.roseColor === 'purple' ? 'checked' : ''} class="mr-2 text-purple-600">
                <span class="text-sm text-gray-600">Purple</span>
              </label>
              <label class="flex items-center">
                <input type="radio" name="rose_color_${layerConfig.id}" value="orange" ${layerConfig.roseColor === 'orange' ? 'checked' : ''} class="mr-2 text-orange-600">
                <span class="text-sm text-gray-600">Orange</span>
              </label>
            </div>
          </div>
        </div>
      </div>
    </div>
  `;
  
  container.appendChild(toppingsControlsDiv);
  
  // Add event listeners for topping controls
  const sprinklesCheckbox = document.getElementById(`toppings_tab_sprinkles_${layerConfig.id}`);
  const sprinklesControls = document.getElementById(`sprinkles_controls_${layerConfig.id}`);
  
  sprinklesCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.sprinkles', e.target.checked);
    sprinklesControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const cherriesCheckbox = document.getElementById(`toppings_tab_cherries_${layerConfig.id}`);
  const cherriesControls = document.getElementById(`cherries_controls_${layerConfig.id}`);
  
  cherriesCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.cherries', e.target.checked);
    cherriesControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const strawberriesCheckbox = document.getElementById(`toppings_tab_strawberries_${layerConfig.id}`);
  const strawberriesControls = document.getElementById(`strawberries_controls_${layerConfig.id}`);
  
  strawberriesCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.strawberries', e.target.checked);
    strawberriesControls.classList.toggle('hidden', !e.target.checked);
  });
  
  // Add event listeners for strawberry position radio buttons
  const strawberryPositionRadios = document.querySelectorAll(`input[name="strawberry_position_${layerConfig.id}"]`);
  strawberryPositionRadios.forEach(radio => {
    radio.addEventListener('change', (e) => {
      if (e.target.checked) {
        updateLayerProperty(layerConfig.id, 'strawberryPosition', e.target.value);
      }
    });
  });
  
  const blueberriesCheckbox = document.getElementById(`toppings_tab_blueberries_${layerConfig.id}`);
  const blueberriesControls = document.getElementById(`blueberries_controls_${layerConfig.id}`);
  
  blueberriesCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.blueberries', e.target.checked);
    blueberriesControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const candleCheckbox = document.getElementById(`toppings_tab_candle_${layerConfig.id}`);
  const candleControls = document.getElementById(`candle_controls_${layerConfig.id}`);
  
  candleCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.candle', e.target.checked);
    candleControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const crushOreoCheckbox = document.getElementById(`toppings_tab_crush_oreo_${layerConfig.id}`);
  const crushOreoControls = document.getElementById(`crush_oreo_controls_${layerConfig.id}`);
  
  crushOreoCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.crush_oreo', e.target.checked);
    crushOreoControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const christmasBallsCheckbox = document.getElementById(`toppings_tab_christmas_balls_${layerConfig.id}`);
  const christmasBallsControls = document.getElementById(`christmas_balls_controls_${layerConfig.id}`);
  
  christmasBallsCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.christmas_balls', e.target.checked);
    christmasBallsControls.classList.toggle('hidden', !e.target.checked);
  });
  
  const flowersCheckbox = document.getElementById(`toppings_tab_flowers_${layerConfig.id}`);
  const flowersControls = document.getElementById(`flowers_controls_${layerConfig.id}`);
  
  flowersCheckbox.addEventListener('change', (e) => {
    updateLayerProperty(layerConfig.id, 'toppings.flowers', e.target.checked);
    flowersControls.classList.toggle('hidden', !e.target.checked);
  });
  
  // Add event listeners for flower position radio buttons
  const flowerPositionRadios = document.querySelectorAll(`input[name="flower_position_${layerConfig.id}"]`);
  flowerPositionRadios.forEach(radio => {
    radio.addEventListener('change', throttledInputHandler((e) => {
      if (e.target.checked) {
        updateLayerProperty(layerConfig.id, 'flowerPosition', e.target.value);
      }
    }, 200));
  });
  
  // Add event listeners for rose color radio buttons
  const roseColorRadios = document.querySelectorAll(`input[name="rose_color_${layerConfig.id}"]`);
  roseColorRadios.forEach(radio => {
    radio.addEventListener('change', throttledInputHandler((e) => {
      if (e.target.checked) {
        updateLayerProperty(layerConfig.id, 'roseColor', e.target.value);
      }
    }, 200));
  });
};

// Add to Cart related reactive variables
const showCartConfirmModal = ref(false);
const showBackConfirmModal = ref(false);
const isLoading = ref(false);

const handleBackButton = (event) => {
  // Prevent default back button behavior
  event.preventDefault();
  showBackConfirmModal.value = true;
};

const confirmBack = () => {
  showBackConfirmModal.value = false;
  resetCustomization();
  router.push('/home');
};

const confirmReset = () => {
  showResetConfirmModal.value = false;
  resetCustomization();
};

// Special instructions for the order
const customerInfo = reactive({
  message: ''
});

// Import cart store
import { useCartStore } from '@/stores/cartStore';
import { toastController } from '@ionic/vue';
const cartStore = useCartStore();

// No required fields in the form anymore, so it's always valid
const isFormValid = computed(() => {
  return true;
});

// Show the add to cart modal
const showAddToCartModal = () => {
  if (cakeLayers.value.length === 0) {
    alert('Please design your cake before adding to cart.');
    return;
  }
  
  if (!selectedSize.value) {
    alert('Please select a cake size before adding to cart.');
    return;
  }
  
  showCartConfirmModal.value = true;
};

// Add the cake to cart and save to Firebase
const addToCart = async () => {
  isLoading.value = true;
  
  try {
    // Ensure the scene is properly rendered from a good angle
    const originalCameraPosition = { ...camera.position };
    
    // Move camera to a better position for capturing the cake
    camera.position.set(
      cakeLayers.value.length > 0 ? cakeLayers.value[0].radius * 2 : 5, 
      cakeLayers.value.reduce((sum, layer) => sum + layer.height, 0) + 3, 
      cakeLayers.value.length > 0 ? cakeLayers.value[0].radius * 2.5 : 5
    );
    camera.lookAt(0, cakeLayers.value.reduce((sum, layer) => sum + layer.height, 0) / 2, 0);
    
    // Force render to ensure scene is updated
    renderer.render(scene, camera);
    
    // Create a rendered image of the cake as base64
    let cakeImageBase64;
    try {
      cakeImageBase64 = renderer.domElement.toDataURL('image/png');
      console.log('Captured cake image successfully');
    } catch (imageError) {
      console.error('Error capturing cake image:', imageError);
      cakeImageBase64 = null; // Will use a fallback image in the cart
    }
    
    // Restore camera to original position
    camera.position.set(originalCameraPosition.x, originalCameraPosition.y, originalCameraPosition.z);
    camera.lookAt(0, 0, 0);
    renderer.render(scene, camera);
    
    // Create a deep copy of the cake design data
    const cakeDesignData = {
      cakeLayers: JSON.parse(JSON.stringify(cakeLayers.value)),
      layerIdCounter: layerIdCounter
    };
    
    // Verify the design data is valid
    if (!cakeDesignData.cakeLayers || cakeDesignData.cakeLayers.length === 0) {
      throw new Error('Cake design is incomplete. Please add at least one layer.');
    }
    
    console.log('Design data to be saved:', cakeDesignData);
    
    // Prepare the cake data without an orderId - this will be added during checkout
    const customCakeItem = {
      name: 'Custom ' + (selectedFlavor.value ? selectedFlavor.value.name : '') + ' Cake',
      size: selectedSize.value ? selectedSize.value.name : '',
      unitPrice: totalPrice.value,
      totalPrice: totalPrice.value,
      quantity: 1,
      imageUrl: cakeImageBase64,
      isCustomCake: true,
      cakeId: 'custom_' + Date.now(), // Generate a unique cakeId for each custom cake
      customDetails: {
        // Save design data exactly as the Save Design button does
        designData: cakeDesignData,
        // Still keep the other important info
        layers: selectedLayers.value,
        flavor: selectedFlavor.value ? JSON.parse(JSON.stringify(selectedFlavor.value)) : null,
        greeting: greetingConfig.enabled ? JSON.parse(JSON.stringify(greetingConfig)) : null,
        message: customerInfo.message.trim() || ''
      }
    };
    
    console.log('Adding custom cake to cart:', customCakeItem);
    
    // Add the custom cake to the cart
    await cartStore.addItem(customCakeItem);
    
    // Hide the cart confirmation modal
    showCartConfirmModal.value = false;
    
    // Reset the customization
    resetCustomization();
    
    // Show success toast
    const toast = await toastController.create({
      message: 'Custom cake added to cart successfully!',
      duration: 2000,
      position: 'top',
      color: 'success'
    });
    await toast.present();
    
    // Redirect to cart page
    router.push('/cart');
    
  } catch (error) {
    console.error('Error adding to cart:', error);
    const toast = await toastController.create({
      message: 'Failed to add custom cake to cart. Please try again.',
      duration: 2000,
      position: 'top',
      color: 'danger'
    });
    await toast.present();
  } finally {
    isLoading.value = false;
  }
};

// Finish the order process - removed as we now redirect directly to cart

const resetCustomization = () => {
  // Reset selection modal state
  showSelectionsModal.value = true;
  currentStep.value = 1;
  selectedLayers.value = 1;
  selectedSize.value = null;
  selectedFlavor.value = null;

  // Reset cake layers
  cakeLayers.value = [];
  layerIdCounter = 0;
  selectedLayerId.value = null;

  // Reset greeting configuration
  greetingConfig.enabled = false;
  greetingConfig.text = '';
  greetingConfig.color = '#000000';
  greetingConfig.size = 0.3;
  greetingConfig.layout = 'horizontal-top';

  // Clear history stack
  historyStack = [];
  const undoButton = document.getElementById('undoBtn');
  if (undoButton) {
    undoButton.disabled = true;
  }

  // Reset customer info
  customerInfo.message = '';

  // Reset active tab to default
  activeTab.value = 'tab-design';

  // Reset 3D view
  if (cakeGroup) {
    while (cakeGroup.children.length) {
      const child = cakeGroup.children[0];
      child.traverse((object) => {
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach(material => material.dispose());
          } else {
            object.material.dispose();
          }
        }
      });
      cakeGroup.remove(child);
    }
  }

  // Add initial layer
  addNewLayerAndSelect();
  renderCake();
};

// Add pricing calculation to consider layers as well
// Add this computed property for displaying total price in the cart modal
const totalPrice = computed(() => {
  if (!selectedSize.value) return 0;
  
  // Use the direct price from the selected size option
  // Since we now have separate pricing for each tier configuration
  return selectedSize.value.price;
});

// Export icons for template use
const icons = {
  cubeOutline,
  settingsOutline,
  constructOutline,
  layersOutline,
  flameOutline,
  iceCreamOutline,
  sparklesOutline,
  chatbubbleOutline,
  cartOutline
};

const saveCakeConfiguration = () => {
  try {
    // Create a deep copy of the cake design data
    const cakeDesignData = {
      cakeLayers: JSON.parse(JSON.stringify(cakeLayers.value)),
      layerIdCounter: layerIdCounter,
      greetingConfig: JSON.parse(JSON.stringify(greetingConfig)),
      timestamp: Date.now()
    };
    
    // Create a downloadable blob
    const dataStr = JSON.stringify(cakeDesignData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    
    // Create download link
    const link = document.createElement('a');
    link.href = URL.createObjectURL(dataBlob);
    link.download = `cake-design-${new Date().toISOString().slice(0, 10)}.json`;
    
    // Trigger download
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    console.log('Cake design saved successfully');
  } catch (error) {
    console.error('Error saving cake design:', error);
    alert('Failed to save cake design. Please try again.');
  }
};

const loadCakeConfiguration = (event) => {
  const file = event.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const designData = JSON.parse(e.target.result);
      
      // Validate the loaded data
      if (!designData.cakeLayers || !Array.isArray(designData.cakeLayers)) {
        throw new Error('Invalid design file format');
      }
      
      // Save current state to history before loading
      saveToHistory();
      
      // Load the design data
      cakeLayers.value = designData.cakeLayers;
      layerIdCounter = designData.layerIdCounter || cakeLayers.value.length;
      
      // Load greeting config if it exists
      if (designData.greetingConfig) {
        Object.assign(greetingConfig, designData.greetingConfig);
      }
      
      // Clear current selection
      selectedLayerId.value = null;
      
      // Re-render the cake
      renderCake();
      
      console.log('Cake design loaded successfully');
    } catch (error) {
      console.error('Error loading cake design:', error);
      alert('Failed to load cake design. Please check the file format.');
    }
  };
  
  reader.readAsText(file);
  // Clear the input so the same file can be loaded again if needed
  event.target.value = '';
};

const addNewLayerAndSelect = () => {
  saveToHistory(); // Save state before making changes
  layerIdCounter++;
  const newLayerId = `layer_${layerIdCounter}`;
  const newLayer = {
    id: newLayerId,
    ...JSON.parse(JSON.stringify(defaultLayerSettings))
  };
  if (cakeLayers.value.length > 0) {
    const topLayer = cakeLayers.value[cakeLayers.value.length - 1];
    newLayer.radius = Math.max(0.5, topLayer.radius - 0.3);
    newLayer.height = Math.max(0.3, topLayer.height - 0.1);
  }
  cakeLayers.value.push(newLayer);
  renderCake();
  selectLayer(newLayerId);
  const layerEditorTabButton = document.querySelector('.tab-button[data-tab="tab-layer-editor"]');
  if (layerEditorTabButton) {
    layerEditorTabButton.click();
  }
};


const selectLayers = (num) => {
  selectedLayers.value = num;
};

const selectSize = (size) => {
  selectedSize.value = size;
};

const selectFlavor = (flavor) => {
  selectedFlavor.value = flavor;
};

const nextStep = () => {
  if (canProceed.value && currentStep.value < 3) {
    currentStep.value++;
  }
};

const previousStep = () => {
  if (currentStep.value > 1) {
    currentStep.value--;
  }
};

const finishSelection = () => {
  if (canProceed.value) {
    showSelectionsModal.value = false;
    generateCakeFromSelections();
  }
};

const generateCakeFromSelections = () => {
  // Clear existing layers
  cakeLayers.value = [];
  layerIdCounter = 0;
  
  // Generate layers based on selection (with 0.5 scaling factor: inches to 3D units)
  for (let i = 0; i < selectedLayers.value; i++) {
    layerIdCounter++;
    const layerId = `layer_${layerIdCounter}`;
    const baseRadius = selectedSize.value ? (selectedSize.value.diameter / 2) : 3;
    const radiusReduction = i * 0.4;
    const layer = {
      id: layerId,
      ...JSON.parse(JSON.stringify(defaultLayerSettings)),
      radius: selectedLayers.value === 1 ? baseRadius : Math.max(0.8, baseRadius - radiusReduction),
      height: selectedSize.value ? (selectedLayers.value === 1 ? selectedSize.value.height * 0.5 : selectedSize.value.height * 0.5 / selectedLayers.value) : 0.8,
      color: selectedFlavor.value ? selectedFlavor.value.color : '#F0E68D'
    };
    cakeLayers.value.push(layer);
    }
  
  // Render the generated cake
  renderCake();
  
  // Auto-select the bottom layer
  if (cakeLayers.value.length > 0) {
    selectLayer(cakeLayers.value[0].id);
  }
};

const renderCake = () => {
  // Safety check to ensure cakeGroup is initialized
  if (!cakeGroup) {
    console.warn('cakeGroup not initialized yet, skipping render');
    return;
  }
  
  // Remove existing cake layers and clean up memory
  const layersToRemove = cakeGroup.children.filter(child => child.userData.isCakeLayer);
  layersToRemove.forEach(child => {
    if (originalLayerMaterials.has(child.userData.layerId) && child.material !== originalLayerMaterials.get(child.userData.layerId)) {
      if (child.material.dispose) child.material.dispose();
    } else if (!originalLayerMaterials.has(child.userData.layerId) && child.material && child.material.dispose) {
      if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
      else child.material.dispose();
    }
    if (child.geometry && child.geometry.dispose) child.geometry.dispose();
    child.traverse(object => {
      if (object.isMesh) {
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
          if (Array.isArray(object.material)) object.material.forEach(m => m.dispose());
          else object.material.dispose();
        }
      }
    });
    cakeGroup.remove(child);
  });
  originalLayerMaterials.clear();

  // Make the cake sit lower on the stand platform for better integration
  let currentHeightOffset = cakeStand.userData.totalHeight - 0.05;
  let topLayerRadius = 0;
  let topLayerHeight = 0;

  if (cakeLayers.value.length > 0) {
    cakeLayers.value.forEach((layerConfig, index) => {
      const layerMesh = createLayerMesh(layerConfig.radius, layerConfig.height, layerConfig.color, layerConfig.id);
      layerMesh.position.y = currentHeightOffset + layerConfig.height / 2;
      addDecorations(layerMesh, layerConfig);
      cakeGroup.add(layerMesh);
      currentHeightOffset += layerConfig.height;
      if (index === cakeLayers.value.length - 1) {
        topLayerRadius = layerConfig.radius;
        topLayerHeight = layerConfig.height;
      }
    });
  }
  
  // Add greeting text after layers
  addGreetingTextToCake(currentHeightOffset, topLayerRadius, topLayerHeight);
  
  // Render the scene
  renderer.render(scene, camera);
};

const onWindowResize = () => {
  if (camera && renderer) {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
};

const addLayerControlsUI = (layerConfig, container) => {
  const layerIndex = cakeLayers.value.findIndex(l => l.id === layerConfig.id) + 1;
  const controlsDiv = document.createElement('div');
  controlsDiv.className = 'p-4 space-y-4';
  
  controlsDiv.innerHTML = `
    <h3 class="text-xl font-bold text-center p-2 my-2">Layer ${layerIndex} Settings</h3>
    
    <div class="bg-white rounded-lg p-4 shadow-sm space-y-4">
      <!-- Layer Radius -->
      <div class="space-y-2">
        <label class="block text-sm font-medium text-gray-700">
          Layer Radius (${layerConfig.radius.toFixed(2)}):
        </label>
        <input type="range" 
          id="layer_radius_${layerConfig.id}"
          min="0.5" 
          max="5" 
          step="0.1"
          value="${layerConfig.radius}"
          class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
      </div>
      
      <!-- Layer Height -->
      <div class="space-y-2">
        <label class="block text-sm font-medium text-gray-700">
          Layer Height (${layerConfig.height.toFixed(2)}):
        </label>
        <input type="range" 
          id="layer_height_${layerConfig.id}"
          min="0.3" 
          max="3" 
          step="0.1"
          value="${layerConfig.height}"
          class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
      </div>
      
      <!-- Layer Color -->
      <div class="space-y-2">
        <label class="block text-sm font-medium text-gray-700">Layer Color:</label>
        <div class="flex items-center gap-3">
          <input type="color" 
            id="layer_color_${layerConfig.id}"
            value="${layerConfig.color}"
            class="w-14 h-10 p-1 border border-gray-300 rounded-md shadow-sm cursor-pointer">
          <span class="text-sm font-mono">${layerConfig.color}</span>
        </div>
      </div>
      
      <!-- Remove Layer Button -->
      <div class="pt-4 border-t">
        <button 
          id="remove_layer_${layerConfig.id}"
          class="w-full px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors duration-200">
          Remove Layer ${layerIndex}
        </button>
      </div>
    </div>
  `;
  
  container.appendChild(controlsDiv);
  
  // Add event listeners for the controls
  document.getElementById(`layer_radius_${layerConfig.id}`).addEventListener('input', (e) => {
    updateLayerProperty(layerConfig.id, 'radius', parseFloat(e.target.value));
    // Update the label
    e.target.previousElementSibling.textContent = `Layer Radius (${parseFloat(e.target.value).toFixed(2)}):`;
  });
  
  document.getElementById(`layer_height_${layerConfig.id}`).addEventListener('input', (e) => {
    updateLayerProperty(layerConfig.id, 'height', parseFloat(e.target.value));
    // Update the label
    e.target.previousElementSibling.textContent = `Layer Height (${parseFloat(e.target.value).toFixed(2)}):`;
  });
  
  document.getElementById(`layer_color_${layerConfig.id}`).addEventListener('input', (e) => {
    updateLayerProperty(layerConfig.id, 'color', e.target.value);
    // Update the color display
    e.target.nextElementSibling.textContent = e.target.value;
  });
  
  document.getElementById(`remove_layer_${layerConfig.id}`).addEventListener('click', () => {
    if (cakeLayers.value.length > 1) {
      removeLayer(layerConfig.id);
  } else {
      alert('Cannot remove the last layer. A cake must have at least one layer.');
    }
  });
};

const updateControlsForSelectedLayer = () => {
  const controlsContainer = document.getElementById('selectedLayerControlsContainer');
  const prompt = document.getElementById('layerEditPrompt');
  controlsContainer.innerHTML = '';
  if (selectedLayerId.value) {
    const layerConfig = cakeLayers.value.find(l => l.id === selectedLayerId.value);
    if (layerConfig) {
      if (prompt) prompt.style.display = 'none';
      addLayerControlsUI(layerConfig, controlsContainer);
    } else {
      if (prompt) {
        prompt.textContent = "Error: Layer data not found.";
        prompt.style.display = 'block';
      }
    }
  } else {
    if (prompt) {
      prompt.textContent = "Click a cake layer in the 3D view to edit it.";
      prompt.style.display = 'block';
    }
  }
};

const startAnimationLoop = () => {
  const animate = () => {
    requestAnimationFrame(animate);
    
    // Add any rotation or animation effects here if needed
    // For now, we'll keep it simple and just render the scene
    
    // Render the scene
    if (renderer && scene && camera) {
      renderer.render(scene, camera);
    }
  };
  
  animate();
};

// Performance optimization functions for smooth control interactions
const throttledInputHandler = (callback, delay = 150) => {
  let timeoutId;
  return (event) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => callback(event), delay);
  };
};

const debouncedRender = (() => {
  let timeoutId;
  return (delay = 50) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
  renderCake();
    }, delay);
  };
})();

// Throttled handlers for topper controls to improve performance
const throttledTopperUpdate = (() => {
  let timeoutId;
  return (property, value) => {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      updateLayerProperty(selectedLayerId.value, property, value);
    }, 150);
  };
})();

const handleThrottledTopperInput = (property, event) => {
  const value = parseFloat(event.target.value);
  throttledTopperUpdate(property, value);
};

const updateLayerProperty = (layerId, propertyPath, value) => {
  if (!layerId) {
    console.warn('No layer selected for property update');
    return;
  }
  
  const layer = cakeLayers.value.find(l => l.id === layerId);
  if (!layer) {
    console.warn('Layer not found:', layerId);
    return;
  }
  
  // Save current state to history before making changes
  saveToHistory();
  
  // Handle nested property paths like 'topper.enabled' or 'edgeIcing.style'
  const pathParts = propertyPath.split('.');
  let target = layer;
  
  // Navigate to the parent object
  for (let i = 0; i < pathParts.length - 1; i++) {
    const part = pathParts[i];
    if (!target[part]) {
      target[part] = {};
    }
    target = target[part];
  }
  
  // Set the final property value
  const finalProperty = pathParts[pathParts.length - 1];
  target[finalProperty] = value;
  
  // Trigger debounced render for better performance
  debouncedRender();
  
  console.log(`Updated ${propertyPath} to:`, value, 'for layer:', layerId);
};

const removeLayer = (layerIdToRemove) => {
  const layerIndex = cakeLayers.value.findIndex(l => l.id === layerIdToRemove);
  if (layerIndex !== -1) {
    saveToHistory(); // Save state before removing
    cakeLayers.value.splice(layerIndex, 1);
    
    // If the removed layer was selected, select another layer or clear selection
    if (selectedLayerId.value === layerIdToRemove) {
      if (cakeLayers.value.length > 0) {
        // Select the layer at the same index, or the last layer if index is out of bounds
        const newIndex = Math.min(layerIndex, cakeLayers.value.length - 1);
        selectLayer(cakeLayers.value[newIndex].id);
      } else {
        selectedLayerId.value = null;
      }
    }
    
    renderCake();
  }
};

const getLayerNumber = (layerId) => {
  if (!layerId || !cakeLayers.value) {
    return 1; // Default to layer 1 if no selection or no layers
  }
  
  const index = cakeLayers.value.findIndex(l => l.id === layerId);
  if (index === -1) {
    return 1; // Default to layer 1 if layer not found
  }
  
  return index + 1; // Convert 0-based index to 1-based layer number
};

// Computed property for reactive layer number
const currentLayerNumber = computed(() => {
  if (!selectedLayerId.value || !cakeLayers.value) {
    return 1; // Default to layer 1 if no selection or no layers
  }
  
  const index = cakeLayers.value.findIndex(l => l.id === selectedLayerId.value);
  if (index === -1) {
    return 1; // Default to layer 1 if layer not found
  }
  
  return index + 1; // Convert 0-based index to 1-based layer number
});

</script>

<style scoped>
.customize-page {
  --background: linear-gradient(135deg, #FFF7D0 0%, #C8AD7E 100%);
}

#cakeCanvas {
  display: block;
  width: 100%;
  height: 100vh;
  position: fixed;
  top: 0;
  left: 0;
  z-index: 0;
  cursor: pointer;
}

.controls-panel {
  position: absolute;
  bottom: 0;
  left: 0;
  width: 100%;
  background-color: rgba(255, 255, 255, 0.97);
  box-shadow: 0 -4px 15px rgba(0, 0, 0, 0.1);
  max-height: 50vh;
  overflow-y: auto;
  z-index: 10;
  transition: all 0.3s ease-in-out;
  box-sizing: border-box;
}

.tabs {
  display: flex;
  gap: 0.5rem;
  margin-bottom: 1rem;
  padding: 1rem;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
  white-space: nowrap;
  scrollbar-width: thin;
  scroll-behavior: smooth;
}

.tabs::-webkit-scrollbar {
  height: 0px;
}

.tabs::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2);
  border-radius: 0px;
}

/* Hide scrollbar for overflow-x-auto containers */
.overflow-x-auto {
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.overflow-x-auto::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.tab-button {
  padding: 0.75rem 1.25rem;
  border: 1px solid #7A5C1E;
  border-radius: 8px;
  color: #333;
  background-color: #f8f9fa;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 0 0 auto;
  min-width: 120px;
  text-align: center;
}

.tab-button:hover {
  background-color: #e9ecef;
  color: #000;
  border-color: #7A5C1E;
}

.tab-button.active {
  background-color: #7A5C1E;
  color: #ffffff;
  border-color: #7A5C1E;
  font-weight: bold;
}

.tab-content {
  display: none;
}

.tab-content.active {
  display: block;
}



.action-button {
  display: block;
  padding: 8px;
  margin-bottom: 8px;
  background: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.action-button:hover {
  background: #0056b3;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 8px;
}

.sub-controls {
  padding-left: 20px;
  border-left: 2px solid #ddd;
}

.prompt {
  color: #666;
  font-style: italic;

  padding: 16px;
}

.layer-header {
  font-weight: 600;
  margin-bottom: 10px;
}

.remove-layer-btn {
  background: #dc3545;
  color: white;
  border: none;
  padding: 8px;
  border-radius: 4px;
  cursor: pointer;
  width: 100%;
}

.remove-layer-btn:hover {
  background: #c82333;
}

.toppings-group {
  margin-top: 5px;
}

.icing-section {
  margin-top: 15px;
  padding-top: 15px;
  border-top: 1px solid #ddd;
}

input[type="range"] {
  width: 100%;
}

input[type="color"] {
  width: 50px;
  height: 25px;
  padding: 0;
  border: 1px solid #ddd;
  border-radius: 4px;
}

select {
  width: 100%;
  padding: 4px;
  border: 1px solid #ddd;
  border-radius: 4px;
  margin-top: 4px;
}

.hidden {
  display: none;
}

/* Updated Modal Styles */
.selections-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: #ffffff;
  z-index: 1000;
  display: flex;
  flex-direction: column;
  padding-top: 56px;
}

.modal-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  padding: 1.5rem 0;
  max-width: 100%;
  margin: 0;
  box-shadow: none;
  background: #ffffff;
  overflow-y: auto;
}

/* Progress Bar Styles */
.progress-container {
  padding: 0.8rem 0;
 
}

.progress-steps {
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
  padding: 0 2rem;
}

.progress-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  position: relative;
  flex: 1;
}

.step-number {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: #e0e0e0;
  color: #666;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: bold;
  margin-bottom: 0.75rem;
  transition: all 0.3s ease;
  font-size: 1.2rem;
}

.progress-step.active .step-number {
  background: #007bff;
  color: white;
  transform: scale(1.1);
}

.progress-step.completed .step-number {
  background: #28a745;
  color: white;
}

.step-label {
  font-size: 1rem;
  color: #666;
  text-align: center;
  font-weight: 500;
}

.progress-bar {
  height: 6px;
  background: #e0e0e0;
  border-radius: 3px;
  margin: 0 2rem;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: #58091F;
  border-radius: 3px;
  transition: width 0.3s ease;
}

/* Step Content Styles */
.step-content {
  flex: 1;
  overflow-y: auto;
  padding: 1rem 0;
}


.selection-step h2 {
  font-size: 1.6rem;
  color: #333;
  text-align: center;
  font-weight: 700;
}

.step-description {
  text-align: center;
  color: #666;
  margin-bottom: 2.5rem;
  font-size: 0.8rem;
  line-height: 1.5;
}

.options-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  padding: 0 0.5rem;
}

.option-button {
  padding: 0.75rem;
  min-height: 10px;
}

.option-icon {
  width: 60px;
  height: 60px;
}

.preview-layer {
  width: 40px;
  height: 14px;
}

.option-label {
  font-size: 0.9rem;
}

/* Navigation Buttons */
.modal-navigation {
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
  padding: 1.25rem;
  background: white;
  border-top: 1px solid rgba(0, 0, 0, 0.08);
  position: sticky;
  bottom: 0;
  box-shadow: 0 -4px 16px rgba(0, 0, 0, 0.05);
  z-index: 10;
}

.nav-button {
  flex: 1;
  padding: 0.875rem 1.5rem;
  font-size: 1rem;
  font-weight: 600;
  border-radius: 8px;
  transition: all 0.2s ease;
  position: relative;
  overflow: hidden;
  border: none;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  min-width: 120px;
  letter-spacing: 0.3px;
}

.nav-button.back {
  background-color: #f5f5f5;
  color: #666;
  border: 1px solid #e0e0e0;
}

.nav-button.back:hover {
  background-color: #eeeeee;
  color: #444;
}

.nav-button.next,
.nav-button.finish {
  background: linear-gradient(135deg, #28a745 0%, #218838 100%);
  color: white;
  box-shadow: 0 2px 4px rgba(40, 167, 69, 0.2);
}

.nav-button.next:hover,
.nav-button.finish:hover {
  background: linear-gradient(135deg, #218838 0%, #1e7e34 100%);
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(40, 167, 69, 0.3);
}

.nav-button:active {
  transform: translateY(1px);
}

.nav-button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}

/* Removed arrow icons */

/* Responsive adjustments */
@media (max-width: 768px) {
  .modal-navigation {
    flex-direction: column;
    padding: 1rem;
  }

  .nav-button {
    width: 100%;
    min-width: unset;
  }
}

/* Layer Selection Styles */
.layers-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 1.25rem;
  max-width: 600px;
  margin: 0 auto;

}

.layer-card {
  display: flex;
  align-items: center;
  gap: 2rem;
  background: #FFFFFF;
  border: 2px solid #E8E8E8;
  border-radius: 16px;
  padding: 1.5rem;
  cursor: pointer;
  transition: all 0.3s ease;
  text-align: left;
  width: 100%;
}

.layer-card:hover {
  transform: translateY(-4px);
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
  border-color: #F0E68D;
}

.layer-card.selected {
  border-color: #58091F;
  background: rgba(240, 230, 141, 0.05);
  box-shadow: 0 8px 24px rgba(88, 9, 31, 0.12);
}

.layer-visual {
  flex: 0 0 120px;
  height: 120px;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.layer-stack {
  position: relative;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}

.cake-layer {
  position: absolute;
  width: 80px;
  height: 30px;
  border-radius: 8px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.layer-details {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.layer-title {
  font-size: 1.25rem;
  font-weight: 700;
  color: #333;
}

.layer-description {
  font-size: 0.9rem;
  color: #666;
  line-height: 1.4;
}

.layer-features {
  display: flex;
  gap: 1rem;
  margin-top: 0.5rem;
}

.feature {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  font-size: 0.875rem;
  color: #555;
  background: #f5f5f5;
  padding: 0.5rem 0.75rem;
  border-radius: 6px;
}

.feature ion-icon {
  font-size: 1.1rem;
  color: #58091F;
}

.layer-card.selected .layer-title {
  color: #58091F;
}



.step-title {
  color: #58091F;
  font-size: 2rem;
  font-weight: 700;
  margin-bottom: 0.75rem;
  line-height: 1.2;
}

.step-description {
  color: #666;
  font-size: 1.1rem;
  max-width: 500px;
  margin: 0 auto;
  line-height: 1.5;
}

/* Responsive Design */
@media (max-width: 768px) {
  .layer-card {
    flex-direction: column;
    gap: 1.5rem;
    padding: 1.25rem;
    align-items: center;
    text-align: center;
  }

  .layer-details {
    align-items: center;
  }

  .layer-features {
    flex-direction: column;
    align-items: center;
    gap: 0.75rem;
  }

  .step-title {
    font-size: 1.75rem;
  }

  .step-description {
    font-size: 1rem;
  }
}

/* Confirmation Modal */
.confirmation-modal {
  width: 95%;
  max-width: none;
}

.form-group input,
.form-group textarea {
  font-size: 16px; /* Prevents zoom on mobile */
}

.option-content {
  display: flex;
  flex-direction: column;
  align-items: center;

  width: 100%;
}

.option-icon {
  width: 100px;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1rem 0;
}



.preview-layer {
  width: 60px;
  height: 20px;
  background: #ffb6c1;
  border-radius: 10px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: all 0.3s ease;
}

.option-button:hover .preview-layer {
  transform: scale(1.05);
}

.option-button.selected .preview-layer {
  transform: scale(1.1);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.option-label {
  font-size: 1.2rem;
  font-weight: 600;
  color: #333;
  text-align: center;
  margin-top: 0.5rem;
}

/* Mobile Responsive Adjustments */
@media (max-width: 768px) {
  .options-grid {
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
    padding: 0 0.5rem;
  }

  .option-button {
    padding: 1rem;
    min-height: 200px;
  }

  .option-icon {
    width: 80px;
    height: 80px;
  }

  .preview-layer {
    width: 50px;
    height: 16px;
  }

  .option-label {
    font-size: 1rem;
  }
}

/* Small Mobile Adjustments */
@media (max-width: 480px) {
  .options-grid {
    grid-template-columns: repeat(2, 1fr);
    gap: 0.75rem;
  }



  .option-icon {
    width: 60px;
    height: 60px;
  }

  .preview-layer {
    width: 40px;
    height: 14px;
  }

  .option-label {
    font-size: 0.9rem;
  }
}

/* Navigation Buttons */
.modal-navigation {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1rem;
  background: white;
  border-top: 1px solid #e0e0e0;
  position: sticky;
  bottom: 0;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.05);
}

.nav-button {
  width: 100%;
  padding: 1rem;
  font-size: 1rem;
  min-width: unset;
  border: none;
  border-radius: 16px;
  cursor: pointer;
  font-weight: 600;
  display: flex;
  align-items: center;
  gap: 1rem;
  transition: all 0.3s ease;
  justify-content: center;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.nav-button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none !important;
}

.nav-button.back {
  background: #f8f9fa;
  color: #666;
  border: 2px solid #e0e0e0;
}

.nav-button.next {
  background: #58091F;
  color: white;
  box-shadow: 0 4px 12px rgba(0, 123, 255, 0.2);
}

.nav-button.finish {
  background: #28a745;
  color: white;
  box-shadow: 0 4px 12px rgba(40, 167, 69, 0.2);
}

.nav-button:hover:not(:disabled) {
  opacity: 0.95;
  transform: translateY(-2px);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.1);
}

.nav-button:active:not(:disabled) {
  transform: translateY(0);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.back-icon, .next-icon, .finish-icon {
  font-size: 1.3rem;
}

/* Mobile Responsive Adjustments for Navigation */
@media (max-width: 768px) {
  .modal-navigation {
    padding: 1.5rem;
  }

  .nav-button {
    padding: 1rem 2rem;
    font-size: 1.1rem;
    min-width: 160px;
  }

  .back-icon, .next-icon, .finish-icon {
    font-size: 1.3rem;
  }
}

@media (max-width: 480px) {
  .modal-navigation {
    padding: 1rem;
    flex-direction: column;
    gap: 1rem;
  }

  .nav-button {
    width: 100%;
    padding: 1rem;
    font-size: 1rem;
    min-width: unset;
  }

  .nav-button.next,
  .nav-button.finish {
    margin-left: 0;
  }
}

/* Responsive Adjustments */
@media (max-width: 480px) {
  .options-grid {
    grid-template-columns: 1fr;
  }



  .option-icon {
    width: 60px;
    height: 60px;
  }

  .nav-button {
    padding: 0.75rem 1rem;
  }
}

/* Mobile-First Header Styles */
ion-header {
  --background: #FFFFFF;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

ion-toolbar {
  --background: #F0E68D;
  --border-width: 0;
  padding: 8px 16px;
}

.back-button {
  --color: #58091F;
}

.customize-title {
  font-size: 1.25rem;
  font-weight: 700;
  color: #58091F;
  letter-spacing: 0.5px;
  padding-left: 16px;
}

/* Mobile-First Form Styles */
.topper-section {
  background-color: #f8f9fa;
  padding: 12px;
  border-radius: 8px;
  margin: 0.5rem;
}

.topper-section select,
.topper-section input[type="text"] {
  width: 100%;
  padding: 8px;
  margin-top: 5px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

.topper-section input[type="file"] {
  width: 100%;
  margin-top: 5px;
}

.topper-section .sub-controls {
  padding: 8px;
  background-color: rgb(255, 0, 0);
  border-radius: 4px;
  margin-top: 8px;
}

/* Mobile-First Step Content */
.step-content {
  padding: 1rem;
}

.selection-step {
  padding: 0.5rem;
}



/* Mobile-First Progress Bar */
.progress-container {
  padding: 1rem 0.5rem;
}

.progress-steps {
  display: flex;
  justify-content: space-between;
  margin-bottom: 1rem;
}

.progress-step {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}

.step-number {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  background: #e0e0e0;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.9rem;
  color: #666;
}

.step-label {
  font-size: 0.8rem;
  color: #666;
}

.progress-step.active .step-number {
  background: #58091F;
  color: white;
}

.progress-step.completed .step-number {
  background: #28a745;
  color: white;
}

.progress-bar {
  height: 4px;
  background: #e0e0e0;
  border-radius: 2px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: #58091F;
  transition: width 0.3s ease;
}

/* Mobile-First Modal */
.selections-modal {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
}

.modal-content {
  background: white;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  position: relative;
  display: flex;
  flex-direction: column;
}

/* Mobile-First Confirmation Modal */
.confirmation-modal {
  width: 95%;
  padding: 1rem;
  border-radius: 12px;
  background: white;
}

.confirmation-header {
  text-align: center;
  margin-bottom: 1rem;
}

.confirmation-title {
  font-size: 1.25rem;
  color: #58091F;
  margin-bottom: 0.5rem;
}

.confirmation-subtitle {
  font-size: 0.9rem;
  color: #666;
}

.form-group {
  margin-bottom: 1rem;
}

.form-group label {
  display: block;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
  color: #333;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 0.75rem;
  border: 1px solid #ddd;
  border-radius: 8px;
  font-size: 16px;
}

.form-group textarea {
  min-height: 100px;
  resize: vertical;
}

.confirmation-actions {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
  margin-top: 1.5rem;
}

.confirmation-button {
  width: 100%;
  padding: 0.75rem;
  border: none;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
}

.cancel-btn {
  background: #f8f9fa;
  color: #666;
  border: 1px solid #ddd;
}

.success-btn {
  background: #28a745;
  color: white;
}

.greeting-control-group {
  margin-top: 10px;
  padding: 10px;
  background: #f8f9fa;
  border-radius: 8px;
}
.greeting-control-group label {
  font-weight: 500;
}
.greeting-control-group .sub-controls {
  margin-top: 10px;
  padding: 10px;
  background: #fff;
  border-radius: 6px;
  border: 1px solid #eee;
}

/* Flavor Selection Styles */
.flavor-grid {
  grid-template-columns: repeat(1, fr);
  gap: 0.75rem;
}

.flavor-preview {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
}

.flavor-preview::after {
  content: '';
  position: absolute;
  width: 80%;
  height: 80%;
  border: 2px dashed #fff;
  border-radius: 50%;
}

.flavor-preview.chocolate {
  background: #4A2C2A;
}

.flavor-preview.ube {
  background: #8A2BE2;
}

.flavor-preview.vanilla {
  background: #F5F5DC;
}

.flavor-preview.mocha {
  background: #6F4E37;
}

.flavor-preview.strawberry {
  background: #FFB6C1;
}

.flavor-description {
  text-align: center;
  color: #666;
  font-size: 0.8rem;
  margin-top: 0.5rem;
  padding: 0.35rem;
  background: #f8f9fa;
  border-radius: 4px;
}

.option-button:hover .flavor-preview {
  transform: scale(1.1);
}

.option-button.selected .flavor-preview {
  transform: scale(1.15);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Topper Controls Styles */
.topper-section {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  padding: 0.75rem;
  margin-bottom: 1rem;
}

.topper-section label {
  display: block;
  margin-bottom: 0.5rem;
  color: #fff;
}

.topper-section input[type="text"] {
  width: 100%;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: #fff;
}

.topper-section select {
  width: 100%;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: #fff;
}

.topper-section input[type="file"] {
  width: 100%;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: #fff;
}

/* Icing Controls Styles */
.icing-section {
  background: rgba(255, 255, 255, 0.05);
  border-radius: 8px;
  padding: 0.75rem;
  margin-bottom: 1rem;
}

.icing-section:last-child {
  margin-bottom: 0;
}

.icing-section label {
  display: block;
  margin-bottom: 0.5rem;
  color: #fff;
}

.icing-section select {
  width: 100%;
  padding: 0.5rem;
  background: rgba(255, 255, 255, 0.1);
  border: 1px solid rgba(255, 255, 255, 0.2);
  border-radius: 4px;
  color: #fff;
}

.icing-section input[type="color"] {
  width: 100%;
  height: 40px;
  padding: 0;
  border: none;
  border-radius: 4px;
  background: none;
}

.icing-section input[type="range"] {
  width: 100%;
  margin: 0.5rem 0;
}

/* Common Styles for Both */
.sub-controls {
  margin-top: 1rem;
  padding-top: 1rem;
  border-top: 1px solid rgba(255, 255, 255, 0.1);
}

.sub-controls.hidden {
  display: none;
}

.checkbox-label {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  cursor: pointer;
}

.checkbox-label input[type="checkbox"] {
  width: 18px;
  height: 18px;
  cursor: pointer;
}

/* Tab Styles */
.tab-button {

  border: 1px solid #7A5C1E;
  border-radius: 8px;
  color: #333;
  background-color: #f8f9fa;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 0 0 auto;
}

.tab-button:hover {
  background-color: #e9ecef;
  color: #000;
  border-color: #7A5C1E;
}

.tab-button.active {
  background-color: #7A5C1E;
  color: #ffffff;
  border-color: #7A5C1E;
  font-weight: bold;
}

.tab-content {
  display: none;
  padding:0;

}

.tab-content.active {
  display: block;
}

.toppings-section {
  background-color: #f8f9fa;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
}

.section-title {
  font-weight: 600;
  margin-bottom: 15px;
  color: #333;
}

.topping-item {
  padding: 10px;
  background-color: white;
  border-radius: 8px;
  border: 1px solid #eee;
}

.topping-description {
  font-size: 0.9rem;
  color: #666;
  margin-top: 5px;
  font-style: italic;
}

.hint-text {
  font-size: 0.9rem;
  color: #999;
  text-align: center;
  font-style: italic;
}

/* Mobile-Friendly Layer Editor Styles */
.mobile-optimized {
  padding: 0;
  margin: 0;
}

.mobile-section-header {
  background-color: #7A5C1E;
  color: white;
  padding: 12px 16px;
  border-radius: 8px;
  margin-bottom: 16px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.layer-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0 0 4px 0;
}

.layer-dimensions p {
  margin: 0;
  font-size: 0.9rem;
  opacity: 0.9;
}

.mobile-control-item {
  background-color: white;
  padding: 16px;
  margin-bottom: 12px;
  border-radius: 8px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.1);
}

.mobile-label {
  display: block;
  font-size: 1rem;
  font-weight: 500;
  margin-bottom: 12px;
  color: #333;
}

.value-display {
  background-color: #f0f0f0;
  padding: 2px 8px;
  border-radius: 12px;
  font-weight: 600;
  margin-left: 6px;
}

.mobile-slider {
  width: 100%;
  height: 24px;
  margin: 8px 0;
  -webkit-appearance: none;
  appearance: none;
  background: #f0f0f0;
  border-radius: 12px;
  outline: none;
}

.mobile-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #7A5C1E;
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.mobile-slider::-moz-range-thumb {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  background: #7A5C1E;
  cursor: pointer;
  border: 2px solid white;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.range-labels {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  color: #666;
  margin-top: 4px;
}

.color-picker-container {
  display: flex;
  align-items: center;
}

.mobile-color-picker {
  -webkit-appearance: none;
  appearance: none;
  width: 48px;
  height: 48px;
  padding: 0;
  border: none;
  border-radius: 8px;
  background: none;
  cursor: pointer;
}

.mobile-color-picker::-webkit-color-swatch {
  border-radius: 8px;
  border: 2px solid white;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.mobile-color-picker::-moz-color-swatch {
  border-radius: 8px;
  border: 2px solid white;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.color-value {
  margin-left: 12px;
  font-family: monospace;
  font-size: 1rem;
  background-color: #f0f0f0;
  padding: 4px 8px;
  border-radius: 4px;
}

.mobile-action-container {
  margin-top: 24px;
  display: flex;
  justify-content: center;
}

.mobile-remove-btn {
  background-color: #ff4b5c;
  color: white;
  border: none;
  padding: 14px 24px;
  border-radius: 8px;
  font-size: 1rem;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  box-shadow: 0 2px 8px rgba(255, 75, 92, 0.3);
  transition: all 0.2s ease;
}

.mobile-remove-btn:active {
  transform: translateY(2px);
  box-shadow: 0 1px 3px rgba(255, 75, 92, 0.3);
}

.btn-icon {
  margin-right: 8px;
  font-size: 1.1rem;
}

/* Confirmation Modal Styles */
.modal-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 2000;
}

.confirmation-modal {
  background-color: white;
  border-radius: 12px;
  width: 95%;
  max-width: none;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  overflow: hidden;
}

.modal-header {
  padding: 16px 20px;
  background-color: #7A5C1E;
  color: white;
}

.modal-header h3 {
  margin: 0;
  font-size: 1.2rem;
  font-weight: 600;
}

.modal-body {
  padding: 20px;
}

.modal-body p {
  margin: 0;
  color: #333;
  line-height: 1.5;
}

.modal-footer {
  padding: 16px 20px;
  display: flex;
  justify-content: flex-end;
  gap: 12px;
  border-top: 1px solid #eee;
}

.cancel-btn {
  padding: 10px 16px;
  background-color: #f5f5f5;
  color: #333;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.cancel-btn:hover {
  background-color: #e5e5e5;
}

.confirm-btn {
  padding: 10px 16px;
  background-color: #dc3545;
  color: white;
  border: none;
  border-radius: 8px;
  font-weight: 500;
  cursor: pointer;
  transition: background-color 0.2s;
}

.confirm-btn:hover {
  background-color: #c82333;
}

/* Add to Cart Button Styles */
.add-to-cart-btn {
  background: #7a1e1e !important;
  font-weight: 700;
  margin-top: 10px;
  text-transform: uppercase;
  letter-spacing: 1px;
  box-shadow: 0 4px 12px rgba(122, 30, 30, 0.3);
  border-radius: 12px;
  padding: 16px 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  
}

.add-to-cart-btn:hover {
  background: #8f2424 !important;
  transform: translateY(-3px);
  box-shadow: 0 6px 16px rgba(122, 30, 30, 0.4);
}

.add-to-cart-btn:active {
  transform: translateY(-1px);
  box-shadow: 0 4px 8px rgba(122, 30, 30, 0.4);
}

.cart-icon {
  font-size: 1.25rem;
  margin-right: 10px;
}

.btn-text {
  font-size: 1.1rem;
}

/* Cart Modal Styles */
.cart-info {
  margin-top: 20px;
}

.price-info {
  background-color: #f8f9fa;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 20px;
}

.price-info h4 {
  color: #333;
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 1.1rem;
}

.price-info p {
  margin: 5px 0;
}

.contact-form {
  margin-top: 20px;
}

.contact-form h4 {
  color: #333;
  margin-top: 0;
  margin-bottom: 15px;
  font-size: 1.1rem;
}

.form-group {
  margin-bottom: 15px;
}

.form-group label {
  display: block;
  margin-bottom: 5px;
  font-weight: 500;
  color: #333;
}

.form-group input,
.form-group textarea {
  width: 100%;
  padding: 10px;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 16px;
}

.form-group textarea {
  height: 80px;
  resize: vertical;
}

/* Success Modal Styles */
.success-modal {
  max-width: 450px;
}

.success-header {
  background-color: #28a745;
}

.success-icon {
  font-size: 60px;
  color: #28a745;
  text-align: center;
  margin: 20px 0;
}

.success-btn {
  background-color: #28a745;
}

.success-btn:hover {
  background-color: #218838;
}



.step-title {
  color: #58091F;
  font-size: 1.75rem;
  font-weight: 700;
  margin-bottom: 0.5rem;
}

.step-description {
  color: #666;
  font-size: 1rem;
  max-width: 400px;
  margin: 0 auto;
}



.layer-option {
  background: #FFFFFF;
  border: 2px solid #E0E0E0;
  border-radius: 16px;
  padding: 1rem;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
}

.layer-option:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border-color: #F0E68D;
}

.layer-option.selected {
  border-color: #58091F;
  background: rgba(240, 230, 141, 0.1);
  box-shadow: 0 4px 16px rgba(88, 9, 31, 0.1);
}

.layer-preview-container {
  width: 80px;
  aspect-ratio: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 1rem;
}



.preview-layer {
  width: 100%;
  height: var(--layer-height);
  background: var(--layer-color);
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
}

.layer-info {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 0.25rem;
}

.layer-number {
  font-size: 1.5rem;
  font-weight: 700;
  color: #58091F;
}

.layer-label {
  font-size: 0.9rem;
  color: #666;
  font-weight: 500;
}

.layer-option.selected .layer-number,
.layer-option.selected .layer-label {
  color: #58091F;
}

/* Add CSS for price display */
.price {
  font-weight: 600;
  color: #28a745;
  font-size: 1.1rem;
  margin-top: 0.25rem;
}

.total-price {
  font-size: 1.1rem;
  margin-top: 10px;
  color: #28a745;
}

.price-info {
  background-color: #f8f9fa;
  padding: 15px;
  border-radius: 8px;
  margin-bottom: 15px;
  border: 1px solid #e0e0e0;
}

/* Mobile-First Design */
.options-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  padding: 0 0.5rem;
}



.option-icon {
  width: 60px;
  height: 60px;
}

.preview-layer {
  width: 40px;
  height: 14px;
}

.option-label {
  font-size: 0.9rem;
}

.modal-navigation {
  display: flex;
  flex-direction: column;
  gap: 1rem;
  padding: 1rem;
  background: white;
  border-top: 1px solid #e0e0e0;
  position: sticky;
  bottom: 0;
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.05);
}

.nav-button {
  width: 100%;
  padding: 0.75rem 1rem;
  font-size: 1rem;
  min-width: unset;
}

.nav-button.next,
.nav-button.finish {
  margin-left: 0;
}

.options-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.75rem;
  margin-bottom: 1.5rem;
  padding: 0 0.5rem;
}

.option-button {
  padding: 0.75rem;
}

.option-icon {
  width: 60px;
  height: 60px;
}

.nav-button {
  padding: 0.75rem 1rem;
}

.size-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); /* Responsive grid */
  gap: 1rem;
  margin-bottom: 1.5rem;
  padding: 0 0.5rem;
}

.size-preview-container {
  width: 100%;
  aspect-ratio: 1; /* Keep preview square */
  display: flex;
  align-items: center;
  justify-content: center;

}

.size-info {
  display: flex;
  flex-direction: column;
  align-items: center;

}

.option-label {
  font-size: 1.2rem;
  font-weight: 600;
  color: #333;
  text-align: center;
  margin-top: 0.5rem;
}

.size-servings {
  font-size: 1rem; /* Slightly larger font for key info */
  font-weight: 600;
  color: #555; /* Different color for servings */
}

.size-price {
  font-weight: 600;
  color: #28a745; /* Green for price */
  font-size: 1.1rem;
  margin-top: 0.25rem;
}

.size-dimensions {
  font-size: 0.8rem; /* Smaller font for detailed dimensions */
  color: #888;
  margin-top: 0.25rem;
}

/* Mobile-Optimized Layer Selection Styles */
.step-header {
  text-align: center;
  padding: 1rem 1rem 0.5rem;
}

.step-title {
  color: #58091F;
  font-size: 1.5rem;
  font-weight: 700;
  margin-bottom: 0.25rem;
}

.step-description {
  color: #666;
  font-size: 1rem;
  margin-bottom: 1.5rem;
}



.layer-option {
  display: flex;
  align-items: center;
  gap: 1rem;
  background: #FFFFFF;
  border: 1px solid #E8E8E8;
  border-radius: 12px;
  padding: 0.75rem;
  cursor: pointer;
  transition: all 0.2s ease;
  width: 100%;
  text-align: left;
}

.layer-option:active {
  transform: scale(0.98);
}

.layer-option.selected {
  border-color: #58091F;
  background: rgba(240, 230, 141, 0.05);
  box-shadow: 0 2px 8px rgba(88, 9, 31, 0.1);
}

.layer-preview {
  position: relative;
  width: 60px;
  height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  flex-shrink: 0;
}

.preview-layer {
  position: absolute;
  width: 50px;
  height: 16px;
  border-radius: 4px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  transition: transform 0.3s ease;
}

.layer-info {
  flex: 1;
  display: flex;
  justify-content: space-between;
  align-items: center;
  min-width: 0;
}

.layer-main-info {
  display: flex;
  flex-direction: column;
  gap: 0.25rem;
}

.layer-name {
  font-size: 1.1rem;
  font-weight: 600;
  color: #333;
}

.layer-servings {
  font-size: 0.9rem;
  color: #666;
}

.layer-price {
  font-size: 1.1rem;
  font-weight: 600;
  color: #28a745;
}

.layer-option.selected .layer-name {
  color: #58091F;
}

/* Hover states only for non-touch devices */
@media (hover: hover) {
  .layer-option:hover {
    border-color: #F0E68D;
    transform: translateY(-2px);
  }
}

/* Additional mobile optimizations */
@media (max-width: 360px) {
  .layer-option {
    padding: 0.5rem;
    gap: 0.75rem;
  }


  .preview-layer {
    width: 40px;
    height: 14px;
  }

  .layer-name {
    font-size: 1rem;
  }

  .layer-servings {
    font-size: 0.8rem;
  }

  .layer-price {
    font-size: 1rem;
  }
}

/* Size Preview Styles */
.size-preview {
  width: 100%;
  height: 100%;
  border-radius: 50%;
  background-color: #F5F5DC;
  border: 2px solid #7A5C1E;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  position: relative;
  transition: all 0.3s ease;
}

/* Different size classes */
.size-6 {
  width: 60px;
  height: 60px;
}

.size-7 {
  width: 70px;
  height: 70px;
}

.size-8 {
  width: 80px;
  height: 80px;
}

.size-9 {
  width: 90px;
  height: 90px;
}

.size-10 {
  width: 100px;
  height: 100px;
}

/* Hover and selected states */
.option-button:hover .size-preview {
  transform: scale(1.05);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.option-button.selected .size-preview {
  transform: scale(1.1);
  box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
  border-color: #58091F;
  background-color: #F0E68D;
}



/* Tier representation styles */
.tier-representation {
  display: flex;
  flex-direction: column;
  align-items: center;
  margin-top: 1rem;
}

.tier-indicator {
  background-color: #F0E68D;
  border: 2px solid #7A5C1E;
  border-radius: 4px;
  margin-bottom: 5px;
}

.no-options-message {
  text-align: center;
  padding: 1.5rem;
  background-color: #f8f9fa;
  border-radius: 8px;
  margin: 1rem 0;
}

.no-options-message p {
  font-size: 1.1rem;
  color: #666;
}

/* Make the size preview container taller for multi-tier cakes */
.option-button:has(.tier-representation) .size-preview-container {
  min-height: 180px;
}

/* Make the size preview container taller for multi-tier cakes */
.multi-tier-preview {
  min-height: 180px;
}


.size-option {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem;
  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.size-option:hover {
  border-color: #F0E68D;
  transform: translateY(-2px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.size-option.selected {
  background: #FFFACD;
  border-color: #F0E68D;
  box-shadow: 0 2px 8px rgba(240, 230, 141, 0.3);
}

.size-name {
  font-weight: 600;
  color: #333;
}

.size-price {
  color: #8B8B00;
  font-weight: 600;
  font-size: 1.2rem;
  margin-top: 0.25rem;
}

.step-description {
  color: #666;
  margin-bottom: 1rem;
}



.size-option {
  display: block;
  width: 100%;

  background: #ffffff;
  border: 1px solid #e0e0e0;
  border-radius: 12px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.size-option:hover {
  border-color: #F0E68D;
  transform: translateY(-2px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

.size-option.selected {
  background: #FFFACD;
  border-color: #F0E68D;
  box-shadow: 0 2px 8px rgba(240, 230, 141, 0.3);
}

.size-content {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
}

.size-visual {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1rem;
}

.cake-circle {
  position: relative;
  background: #FFFACD;
  border: 2px solid #F0E68D;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.size-label {
  font-size: 0.875rem;
  font-weight: 600;
  color: #8B8B00;
}

.size-details {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
  text-align: center;
}

.size-name {
  font-weight: 600;
  color: #333;
  font-size: 1.1rem;
}

.size-dimensions {
  color: #666;
  font-size: 0.9rem;
}

.size-price {
  color: #8B8B00;
  font-weight: 600;
  font-size: 1.2rem;
  margin-top: 0.25rem;
}

.step-description {
  color: #666;
  margin-bottom: 1rem;
}
</style> 